{
  "generatedAt": "2026-02-07T11:38:38.906Z",
  "summary": "This is a React tic-tac-toe project with a Tambo chat interface. Context contains 71 files (66 source, 5 config/docs). Use listed resources to answer project-specific questions and include file paths when possible.",
  "resources": [
    {
      "uri": "file:///LICENSE.md",
      "path": "LICENSE.md",
      "name": "LICENSE.md",
      "mimeType": "text/markdown",
      "text": "MIT License\r\n\r\nCopyright (c) 2023 Ekaterine (Catherine) Mitagvaria\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n",
      "truncated": false
    },
    {
      "uri": "file:///package.json",
      "path": "package.json",
      "name": "package.json",
      "mimeType": "application/json",
      "text": "{\r\n  \"name\": \"tictactoe\",\r\n  \"version\": \"0.1.0\",\r\n  \"private\": true,\r\n  \"homepage\": \"https://catherineisonline.github.io/tic-tac-toe\",\r\n  \"dependencies\": {\r\n    \"@radix-ui/react-collapsible\": \"^1.1.12\",\r\n    \"@radix-ui/react-dropdown-menu\": \"^2.1.16\",\r\n    \"@radix-ui/react-popover\": \"^1.1.15\",\r\n    \"@radix-ui/react-slot\": \"^1.2.4\",\r\n    \"@tambo-ai/react\": \"^0.74.1\",\r\n    \"@tambo-ai/typescript-sdk\": \"^0.89.0\",\r\n    \"@testing-library/jest-dom\": \"^5.16.5\",\r\n    \"@testing-library/react\": \"^13.3.0\",\r\n    \"@testing-library/user-event\": \"^13.5.0\",\r\n    \"@tiptap/extension-document\": \"^3.19.0\",\r\n    \"@tiptap/extension-hard-break\": \"^3.19.0\",\r\n    \"@tiptap/extension-mention\": \"^3.19.0\",\r\n    \"@tiptap/extension-paragraph\": \"^3.19.0\",\r\n    \"@tiptap/extension-placeholder\": \"^3.19.0\",\r\n    \"@tiptap/extension-text\": \"^3.19.0\",\r\n    \"@tiptap/react\": \"^3.19.0\",\r\n    \"@tiptap/suggestion\": \"^3.19.0\",\r\n    \"@valibot/to-json-schema\": \"^1.5.0\",\r\n    \"class-variance-authority\": \"^0.7.1\",\r\n    \"dompurify\": \"^3.3.1\",\r\n    \"effect\": \"^3.19.16\",\r\n    \"framer-motion\": \"^12.33.0\",\r\n    \"highlight.js\": \"^11.11.1\",\r\n    \"json-stringify-pretty-compact\": \"^4.0.0\",\r\n    \"lucide-react\": \"^0.563.0\",\r\n    \"quansync\": \"^1.0.0\",\r\n    \"radix-ui\": \"^1.4.3\",\r\n    \"react\": \"^18.2.0\",\r\n    \"react-dom\": \"^18.2.0\",\r\n    \"react-router-dom\": \"^6.22.2\",\r\n    \"react-scripts\": \"5.0.1\",\r\n    \"streamdown\": \"^2.1.0\",\r\n    \"sury\": \"^10.0.4\",\r\n    \"use-debounce\": \"^10.1.0\",\r\n    \"valibot\": \"^1.2.0\",\r\n    \"web-vitals\": \"^2.1.4\"\r\n  },\r\n  \"scripts\": {\n    \"context:refresh\": \"node scripts/generate-project-context.js\",\n    \"predeploy\": \"npm run build\",\n    \"deploy\": \"gh-pages -d build\",\n    \"start\": \"npm run context:refresh && react-scripts start\",\n    \"build\": \"npm run context:refresh && react-scripts build\",\n    \"test\": \"react-scripts test\",\n    \"eject\": \"react-scripts eject\"\n  },\n  \"eslintConfig\": {\r\n    \"extends\": [\r\n      \"react-app\",\r\n      \"react-app/jest\"\r\n    ]\r\n  },\r\n  \"browserslist\": {\r\n    \"production\": [\r\n      \">0.2%\",\r\n      \"not dead\",\r\n      \"not op_mini all\"\r\n    ],\r\n    \"development\": [\r\n      \"last 1 chrome version\",\r\n      \"last 1 firefox version\",\r\n      \"last 1 safari version\"\r\n    ]\r\n  },\r\n  \"devDependencies\": {\r\n    \"autoprefixer\": \"^10.4.24\",\r\n    \"clsx\": \"^2.1.1\",\r\n    \"gh-pages\": \"^6.1.1\",\r\n    \"postcss\": \"^8.5.6\",\r\n    \"tailwind-merge\": \"^3.4.0\",\r\n    \"tailwindcss\": \"^4.1.18\"\r\n  }\r\n}\r\n",
      "truncated": false
    },
    {
      "uri": "file:///public/index.html",
      "path": "public/index.html",
      "name": "index.html",
      "mimeType": "text/html",
      "text": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\r\n<head>\r\n  <meta charset=\"utf-8\" />\r\n  <meta name=\"description\" content=\"Tic Tac Toe\">\r\n  <meta name=\"keywords\" content=\"Tic Tac Toe, JavaScript game, Frontend game\">\r\n  <link rel=\"icon\" href=\"%PUBLIC_URL%/favicon.ico\" />\r\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\r\n  <meta name=\"theme-color\" content=\"#000000\" />\r\n  <meta name=\"description\" content=\"Tic Tac Toe Game\">\r\n  <meta name=\"keywords\" content=\"Tic Tac Toe Game, React Game\">\r\n  <link rel=\"apple-touch-icon\" href=\"%PUBLIC_URL%/logo192.png\" />\r\n  <link rel=\"manifest\" href=\"%PUBLIC_URL%/manifest.json\" />\r\n\r\n  <title>Tic Tac Toe</title>\r\n</head>\r\n\r\n<body>\r\n  <main id=\"root\"></main>\r\n</body>\r\n\r\n</html>",
      "truncated": false
    },
    {
      "uri": "file:///README.md",
      "path": "README.md",
      "name": "README.md",
      "mimeType": "text/markdown",
      "text": "Integrate Tambo into an existing React app\r\n\r\n![Tic Tac Toe](https://github.com/catherineisonline/tic-tac-toe/blob/main/src/assets/images/project-preview.png?raw=true)\r\n# Tic Tac Toe\r\n\r\n\r\n[Tic Tac Toe](https://catherineisonline.github.io/tic-tac-toe/) game, a classic game for two players where each player takes turns marking a grid of 3x3 squares with their X or O. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game. It is also known as Noughts and Crosses or Xs and Os. The game is implemented using React and CSS\r\n\r\n## Game rules\r\n\r\n1. The game is played on a grid that is 3 squares by 3 squares\r\n2. You are X, your friend is O. Players take turns putting their marks in empty squares\r\n3. The first player to get 3 of their marks in a row (up, down, across, or diagonally) is the winner\r\n4. When all 9 squares are full, the game is over\r\n\r\n## Getting Started with Create React App\r\n\r\nThis project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).\r\n\r\n## Available Scripts\r\n\r\nIn the project directory, you can run:\r\n\r\n### `npm start`\r\n\r\nRuns the app in the development mode.\\\r\nOpen [http://localhost:3000](http://localhost:3000) to view it in your browser.\r\n\r\nThe page will reload when you make changes.\\\r\nYou may also see any lint errors in the console.\r\n\r\n### `npm test`\r\n\r\nLaunches the test runner in the interactive watch mode.\\\r\nSee the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.\r\n\r\n### `npm run build`\r\n\r\nBuilds the app for production to the `build` folder.\\\r\nIt correctly bundles React in production mode and optimizes the build for the best performance.\r\n\r\nThe build is minified and the filenames include the hashes.\\\r\nYour app is ready to be deployed!\r\n\r\nSee the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.\r\n",
      "truncated": false
    },
    {
      "uri": "file:///scripts/generate-project-context.js",
      "path": "scripts/generate-project-context.js",
      "name": "generate-project-context.js",
      "mimeType": "text/plain",
      "text": "const fs = require(\"fs\");\nconst path = require(\"path\");\n\nconst PROJECT_ROOT = path.resolve(__dirname, \"..\");\nconst OUTPUT_FILE = path.join(PROJECT_ROOT, \"public\", \"project-context.json\");\n\nconst IGNORED_DIRS = new Set([\n  \".git\",\n  \"node_modules\",\n  \"build\",\n  \"coverage\",\n  \".vscode\",\n  \".idea\",\n]);\n\nconst INCLUDED_EXTENSIONS = new Set([\n  \".js\",\n  \".jsx\",\n  \".ts\",\n  \".tsx\",\n  \".json\",\n  \".css\",\n  \".md\",\n  \".txt\",\n  \".html\",\n]);\n\nconst EXCLUDED_FILES = new Set([\n  \".env.local\",\n  \".env\",\n  \"package-lock.json\",\n]);\n\nconst MAX_FILES = 120;\nconst MAX_CHARS_PER_FILE = 12000;\nconst MAX_TOTAL_CHARS = 500000;\n\nfunction toPosixPath(filePath) {\n  return filePath.split(path.sep).join(\"/\");\n}\n\nfunction isBinaryLike(content) {\n  return content.includes(\"\\u0000\");\n}\n\nfunction getMimeType(filePath) {\n  const ext = path.extname(filePath).toLowerCase();\n  switch (ext) {\n    case \".json\":\n      return \"application/json\";\n    case \".md\":\n      return \"text/markdown\";\n    case \".css\":\n      return \"text/css\";\n    case \".html\":\n      return \"text/html\";\n    default:\n      return \"text/plain\";\n  }\n}\n\nfunction collectFiles(dirPath, acc) {\n  const entries = fs.readdirSync(dirPath, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const fullPath = path.join(dirPath, entry.name);\n    const relativePath = path.relative(PROJECT_ROOT, fullPath);\n    const normalized = toPosixPath(relativePath);\n\n    if (entry.isDirectory()) {\n      if (IGNORED_DIRS.has(entry.name)) continue;\n      collectFiles(fullPath, acc);\n      continue;\n    }\n\n    if (!INCLUDED_EXTENSIONS.has(path.extname(entry.name).toLowerCase())) continue;\n    if (EXCLUDED_FILES.has(entry.name)) continue;\n    if (normalized.startsWith(\"public/\") && normalized !== \"public/index.html\") continue;\n\n    acc.push({\n      fullPath,\n      relativePath: normalized,\n    });\n  }\n}\n\nfunction loadResources() {\n  const files = [];\n  collectFiles(PROJECT_ROOT, files);\n\n  files.sort((a, b) => a.relativePath.localeCompare(b.relativePath));\n\n  const resources = [];\n  let totalChars = 0;\n\n  for (const file of files) {\n    if (resources.length >= MAX_FILES) break;\n    if (totalChars >= MAX_TOTAL_CHARS) break;\n\n    const rawContent = fs.readFileSync(file.fullPath, \"utf8\");\n    if (isBinaryLike(rawContent)) continue;\n\n    const availableChars = Math.max(0, MAX_TOTAL_CHARS - totalChars);\n    const cap = Math.min(MAX_CHARS_PER_FILE, availableChars);\n    if (cap === 0) break;\n\n    const isTruncated = rawContent.length > cap;\n    const text = isTruncated\n      ? `${rawContent.slice(0, cap)}\\n\\n/* content truncated */`\n      : rawContent;\n\n    totalChars += text.length;\n\n    resources.push({\n      uri: `file:///${file.relativePath}`,\n      path: file.relativePath,\n      name: path.basename(file.relativePath),\n      mimeType: getMimeType(file.relativePath),\n      text,\n      truncated: isTruncated,\n    });\n  }\n\n  return resources;\n}\n\nfunction buildSummary(resources) {\n  const sourceFiles = resources.filter((file) => file.path.startsWith(\"src/\")).length;\n  const configFiles = resources.filter((file) => !file.path.startsWith(\"src/\")).length;\n\n  return [\n    \"This is a React tic-tac-toe project with a Tambo chat interface.\",\n    `Context contains ${resources.length} files (${sourceFiles} source, ${configFiles} config/docs).`,\n    \"Use listed resources to answer project-specific questions and include file paths when possible.\",\n  ].join(\" \");\n}\n\nfunction main() {\n  const resources = loadResources();\n  const payload = {\n    generatedAt: new Date().toISOString(),\n    summary: buildSummary(resources),\n    resources,\n  };\n\n  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });\n  fs.writeFileSync(OUTPUT_FILE, JSON.stringify(payload, null, 2), \"utf8\");\n\n  console.log(\n    `Generated ${path.relative(PROJECT_ROOT, OUTPUT_FILE)} with ${resources.length} resources.`\n  );\n}\n\nmain();\n",
      "truncated": false
    },
    {
      "uri": "file:///src/app/globals.css",
      "path": "src/app/globals.css",
      "name": "globals.css",
      "mimeType": "text/css",
      "text": "@import \"tailwindcss\";\n\n@custom-variant dark (&:is(.dark *));\n\n@theme inline {\n  /* Tailwind CSS Variables customized with tambo colors */\n  --color-background: var(--background);\n  --color-foreground: var(--foreground);\n  --color-card: var(--card);\n  --color-card-foreground: var(--card-foreground);\n  --color-popover: var(--popover);\n  --color-popover-foreground: var(--popover-foreground);\n  --color-primary: var(--primary);\n  --color-primary-foreground: var(--primary-foreground);\n  --color-secondary: var(--secondary);\n  --color-secondary-foreground: var(--secondary-foreground);\n  --color-muted: var(--muted);\n  --color-muted-foreground: var(--muted-foreground);\n  --color-accent: var(--accent);\n  --color-accent-foreground: var(--accent-foreground);\n  --color-destructive: var(--destructive);\n  --color-border: var(--border);\n  --color-input: var(--input);\n  --color-ring: var(--ring);\n  --color-chart-1: var(--chart-1);\n  --color-chart-2: var(--chart-2);\n  --color-chart-3: var(--chart-3);\n  --color-chart-4: var(--chart-4);\n  --color-chart-5: var(--chart-5);\n\n  /* Tambo Specific Variables needed for tambo components */\n  --color-container: var(--container);\n  --color-backdrop: var(--backdrop);\n  --color-muted-backdrop: var(--muted-backdrop);\n}\n\n:root {\n  /* Default Tailwind CSS Variables customized with tambo colors */\n  --background: oklch(1 0 0);\n  --foreground: oklch(0.14 0 285);\n  --card: oklch(1 0 0);\n  --card-foreground: oklch(0.14 0 285);\n  --popover: oklch(1 0 0);\n  --popover-foreground: oklch(0.14 0 285);\n  --primary: oklch(0.31 0.02 281);\n  --primary-foreground: oklch(0.98 0 0);\n  --secondary: oklch(0.9676 0.0013 286.4);\n  --secondary-foreground: oklch(0.2103 0.0059 285.9);\n  --muted: oklch(0.92 0 260);\n  --muted-foreground: oklch(0.5519 0.0137 285.9);\n  --accent: oklch(0.97 0 286);\n  --accent-foreground: oklch(0.21 0 286);\n  --destructive: oklch(0.64 0.2 25);\n  --border: oklch(0.9219 0.0096 242.3);\n  --input: oklch(0.9197 0.004 286.3);\n  --ring: oklch(0.14 0 285);\n  --chart-1: oklch(0.72 0.15 60);\n  --chart-2: oklch(0.62 0.2 6);\n  --chart-3: oklch(0.53 0.2 262);\n  --chart-4: oklch(0.7 0.13 165);\n  --chart-5: oklch(0.62 0.2 313);\n\n  /* Tambo Specific Variables needed for tambo components */\n  --container: oklch(0.98 0 247);\n  --backdrop: oklch(0.25 0.07 252 / 0.25);\n  --muted-backdrop: oklch(0.25 0.07 252 / 0.1);\n  --radius: 0.5rem;\n  --panel-left-width: 500px;\n  --panel-right-width: 500px;\n  --sidebar-width: 3rem;\n}\n\n.dark {\n  /* Dark Mode Tailwind CSS Variables customized with tambo colors */\n  --background: oklch(0.145 0 0);\n  --foreground: oklch(0.985 0 0);\n  --card: oklch(0.205 0 0);\n  --card-foreground: oklch(0.985 0 0);\n  --popover: oklch(0.205 0 0);\n  --popover-foreground: oklch(0.985 0 0);\n  --primary: oklch(0.922 0 0);\n  --primary-foreground: oklch(0.205 0 0);\n  --secondary: oklch(0.269 0 0);\n  --secondary-foreground: oklch(0.985 0 0);\n  --muted: oklch(0.269 0 0);\n  --muted-foreground: oklch(0.708 0 0);\n  --accent: oklch(0.269 0 0);\n  --accent-foreground: oklch(0.985 0 0);\n  --destructive: oklch(0.704 0.191 22.216);\n  --border: oklch(1 0 0 / 10%);\n  --input: oklch(1 0 0 / 15%);\n  --ring: oklch(0.556 0 0);\n  --chart-1: oklch(0.72 0.15 60);\n  --chart-2: oklch(0.62 0.2 6);\n  --chart-3: oklch(0.53 0.2 262);\n  --chart-4: oklch(0.7 0.13 165);\n  --chart-5: oklch(0.62 0.2 313);\n\n  /* Tambo Specific Variables needed for tambo components */\n  --container: oklch(0.22 0 0);\n  --backdrop: oklch(0.85 0 0 / 0.15);\n  --muted-backdrop: oklch(0.85 0 0 / 0.08);\n  --radius: 0.5rem;\n  --panel-left-width: 500px;\n  --panel-right-width: 500px;\n  --sidebar-width: 3rem;\n}\n\n@layer base {\n  * {\n    @apply border-border outline-ring/50;\n  }\n  body {\n    @apply bg-background text-foreground;\n    font-family: Arial, Helvetica, sans-serif;\n  }\n}\n\n/*\nAnimated gradient for thinking text, creates a shimmering effect that moves across the text.\n*/\n@keyframes thinking-gradient {\n  0% {\n    background-position: -200% center;\n  }\n  100% {\n    background-position: 200% center;\n  }\n}\n\n@utility animate-thinking-gradient {\n  /* Light mode gradient - dark text shimmer */\n  background: linear-gradient(\n    90deg,\n    oklch(0.4 0 0) 0%,\n    oklch(0.7 0 0) 50%,\n    oklch(0.4 0 0) 100%\n  );\n  background-size: 200% 100%;\n  background-clip: text;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  animation: thinking-gradient 2s linear infinite;\n\n  .dark & {\n    /* Dark mode gradient - light text shimmer */\n    background: linear-gradient(\n      90deg,\n      oklch(0.6 0 0) 0%,\n      oklch(0.9 0 0) 50%,\n      oklch(0.6 0 0) 100%\n    );\n    background-size: 200% 100%;\n    background-clip: text;\n    -webkit-background-clip: text;\n    -webkit-text-fill-color: transparent;\n    animation: thinking-gradient 2s linear infinite;\n  }\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/app/layout.tsx",
      "path": "src/app/layout.tsx",
      "name": "layout.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { TamboProvider } from \"@tambo-ai/react\";\nimport \"./globals.css\";\n\ndeclare const process: {\n  env: {\n    NEXT_PUBLIC_TAMBO_API_KEY?: string;\n    [key: string]: string | undefined;\n  };\n};\n\nexport default function RootLayout({\n  children,\n}: {\n  children: React.ReactNode;\n}) {\n  return (\n    <html lang=\"en\">\n      <body>\n        <TamboProvider apiKey={process.env.NEXT_PUBLIC_TAMBO_API_KEY ?? \"\"}>\n          {children}\n        </TamboProvider>\n      </body>\n    </html>\n  );\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/app/page.tsx",
      "path": "src/app/page.tsx",
      "name": "page.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { MessageThreadCollapsible } from \"../components/tambo/message-thread-collapsible\";\n\nexport default function Home() {\n  return (\n    <main>\n      <MessageThreadCollapsible />\n    </main>\n  );\n}",
      "truncated": false
    },
    {
      "uri": "file:///src/components/board/Board.js",
      "path": "src/components/board/Board.js",
      "name": "Board.js",
      "mimeType": "text/plain",
      "text": "import Square from '../square/Square'\r\n\r\nconst Board = ({ squares, onClick, jumpTo }) => {\r\n  const renderSquare = (i) => {\r\n    return <Square value={squares[i]} onClick={() => onClick(i)} />\r\n  }\r\n  return (\r\n    <section className=\"game-section\">\r\n      <section className=\"game-board\">\r\n        <section className=\"board-row\">\r\n          {renderSquare(0)}\r\n          {renderSquare(1)}\r\n          {renderSquare(2)}\r\n        </section>\r\n        <section className=\"board-row\">\r\n          {renderSquare(3)}\r\n          {renderSquare(4)}\r\n          {renderSquare(5)}\r\n        </section>\r\n        <section className=\"board-row\">\r\n          {renderSquare(6)}\r\n          {renderSquare(7)}\r\n          {renderSquare(8)}\r\n        </section>\r\n      </section>\r\n      <button className=\"restart\" onClick={() => jumpTo(0)}>\r\n        Restart the game\r\n      </button>\r\n    </section>\r\n  )\r\n}\r\n\r\nexport default Board\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/game-info/GameInfo.js",
      "path": "src/components/game-info/GameInfo.js",
      "name": "GameInfo.js",
      "mimeType": "text/plain",
      "text": "import Friends from '../../assets/images/friends.webp'\r\n\r\nconst GameInfo = ({ status, winner, xIsNext }) => {\r\n  return (\r\n    <section className=\"game-information\">\r\n      {xIsNext && !winner ? (\r\n        <h3 className=\"player-x\">It's your turn, player X</h3>\r\n      ) : !xIsNext && !winner ? (\r\n        <h3 className=\"player-o\">Now you, player O! </h3>\r\n      ) : winner && status === 'Winner: X' ? (\r\n        <h3 className=\"player-x\">Nice! I won! </h3>\r\n      ) : (\r\n        <h3 className=\"player-o\">Wohoo! I made it!</h3>\r\n      )}\r\n      <img src={Friends} alt=\"Player X and Player O\" />\r\n    </section>\r\n  )\r\n}\r\n\r\nexport default GameInfo\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/moves/Moves.js",
      "path": "src/components/moves/Moves.js",
      "name": "Moves.js",
      "mimeType": "text/plain",
      "text": "import React from 'react'\r\n\r\nconst Moves = ({ history, jumpTo }) => {\r\n  const moves = history.map((step, move) => {\r\n    const desc = move ? 'Go to move #' + move : 'Go to game start'\r\n    return (\r\n      <li key={move}>\r\n        <button onClick={() => jumpTo(move)}>{desc}</button>\r\n      </li>\r\n    )\r\n  })\r\n  return <React.Fragment>{moves}</React.Fragment>\r\n}\r\n\r\nexport default Moves\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/square/Square.js",
      "path": "src/components/square/Square.js",
      "name": "Square.js",
      "mimeType": "text/plain",
      "text": "const Square = ({ value, onClick }) => {\r\n  return (\r\n    <button className=\"square\" onClick={onClick}>\r\n      {value}\r\n    </button>\r\n  )\r\n}\r\n\r\nexport default Square\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/content/message-content.tsx",
      "path": "src/components/tambo/base/message/content/message-content.tsx",
      "name": "message-content.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport { TamboThreadMessage } from \"@tambo-ai/react\";\nimport {\n  checkHasContent,\n  convertContentToMarkdown,\n} from \"@/lib/thread-hooks\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { useMessageRootContext } from \"../root/message-root-context\";\n\n/**\n * Props passed to the renderContent callback.\n */\nexport interface MessageContentRenderProps {\n  /** The resolved content to render (from children, content prop, or message). */\n  content: unknown;\n  /** The content converted to markdown string. */\n  markdownContent: string;\n  /** Whether markdown rendering is enabled. */\n  markdown: boolean;\n  /** Whether the content is currently loading. */\n  isLoading: boolean;\n  /** Whether the message has been cancelled. */\n  isCancelled: boolean;\n  /** Whether the message is in reasoning state. */\n  isReasoning: boolean;\n}\n\nexport interface MessageContentProps extends Omit<\n  React.HTMLAttributes<HTMLDivElement>,\n  \"content\" | \"children\"\n> {\n  /** Optional override for the message content. */\n  content?: string | TamboThreadMessage[\"content\"];\n  /** Whether to render as Markdown. Default is true. */\n  markdown?: boolean;\n}\n\n/**\n * Content primitive for displaying message text.\n * Handles content resolution, markdown conversion, and loading state detection.\n * The actual rendering is delegated to the children render prop.\n */\nexport const MessageContent = React.forwardRef<\n  HTMLDivElement,\n  BasePropsWithChildrenOrRenderFunction<\n    MessageContentProps,\n    MessageContentRenderProps\n  >\n>(({ content: contentProp, markdown = true, asChild, ...props }, ref) => {\n  const { message, isLoading } = useMessageRootContext();\n  const contentToRender = contentProp ?? message.content;\n\n  const markdownContent = React.useMemo(\n    () => convertContentToMarkdown(contentToRender),\n    [contentToRender],\n  );\n\n  const hasContent = React.useMemo(\n    () => checkHasContent(contentToRender),\n    [contentToRender],\n  );\n\n  const showLoading = !!isLoading && !hasContent && !message.reasoning;\n\n  const Comp = asChild ? Slot : \"div\";\n\n  const { content, componentProps } = useRender(props, {\n    content: contentToRender,\n    markdownContent,\n    markdown,\n    isLoading: showLoading,\n    isCancelled: !!message.isCancelled,\n    isReasoning: !!message.reasoning,\n  });\n\n  return (\n    <Comp\n      ref={ref}\n      data-slot=\"message-content\"\n      data-loading={showLoading || undefined}\n      data-has-content={hasContent || undefined}\n      {...componentProps}\n    >\n      {content}\n    </Comp>\n  );\n});\nMessageContent.displayName = \"Message.Content\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/images/message-images.tsx",
      "path": "src/components/tambo/base/message/images/message-images.tsx",
      "name": "message-images.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport { getMessageImages } from \"@/lib/thread-hooks\";\nimport * as React from \"react\";\nimport { useMessageRootContext } from \"../root/message-root-context\";\n\n/**\n * Props passed to the renderImage callback.\n */\nexport interface MessageImageRenderFnProps {\n  /** The image URL. */\n  url: string;\n  /** The index of the image in the list. */\n  index: number;\n  /** The alt text for the image. */\n  alt?: string;\n}\n\nexport interface MessageImagesProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n  /**\n   * Render prop for each image. If not provided, renders basic img elements.\n   */\n  renderImage?: (props: MessageImageRenderFnProps) => React.ReactNode;\n  /** Children to render instead of the default image list. */\n  children?: React.ReactNode;\n}\n\n/**\n * Images primitive for displaying message images.\n * Extracts images from message content and renders them.\n */\nexport const MessageImages = React.forwardRef<\n  HTMLDivElement,\n  MessageImagesProps\n>(({ asChild, renderImage, children, ...props }, ref) => {\n  const { message } = useMessageRootContext();\n  const images = getMessageImages(message.content);\n\n  if (images.length === 0) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp ref={ref} data-slot=\"message-images\" {...props}>\n      {children ??\n        images.map((url: string, index: number) =>\n          renderImage ? (\n            <React.Fragment key={index}>\n              {renderImage({ url, index })}\n            </React.Fragment>\n          ) : (\n            <img key={index} src={url} alt={`Image ${index + 1}`} />\n          ),\n        )}\n    </Comp>\n  );\n});\nMessageImages.displayName = \"Message.Images\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/index.tsx",
      "path": "src/components/tambo/base/message/index.tsx",
      "name": "index.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { MessageContent } from \"./content/message-content\";\nimport { MessageImages } from \"./images/message-images\";\nimport { MessageLoadingIndicator } from \"./loading-indicator/message-loading-indicator\";\nimport { MessageRenderedComponent } from \"./rendered-component/rendered-component\";\nimport { MessageRenderedComponentCanvasButton } from \"./rendered-component/rendered-component-canvas-button\";\nimport { MessageRenderedComponentContent } from \"./rendered-component/rendered-component-content\";\nimport { MessageRoot } from \"./root/message-root\";\n\n/**\n * Message namespace containing all message base components.\n */\nconst Message = {\n  Root: MessageRoot,\n  Content: MessageContent,\n  Images: MessageImages,\n  LoadingIndicator: MessageLoadingIndicator,\n  RenderedComponent: MessageRenderedComponent,\n  RenderedComponentContent: MessageRenderedComponentContent,\n  RenderedComponentCanvasButton: MessageRenderedComponentCanvasButton,\n};\n\nexport type {\n  MessageContentProps,\n  MessageContentRenderProps,\n} from \"./content/message-content\";\nexport type {\n  MessageImageRenderFnProps,\n  MessageImagesProps,\n} from \"./images/message-images\";\nexport type { MessageLoadingIndicatorProps } from \"./loading-indicator/message-loading-indicator\";\nexport type { MessageRenderedComponentProps } from \"./rendered-component/rendered-component\";\nexport type { MessageRootProps } from \"./root/message-root\";\n\nexport { Message };\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/loading-indicator/message-loading-indicator.tsx",
      "path": "src/components/tambo/base/message/loading-indicator/message-loading-indicator.tsx",
      "name": "message-loading-indicator.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BaseProps } from \"../../types/component-render-or-children\";\n\nexport type MessageLoadingIndicatorProps = BaseProps<\n  React.HTMLAttributes<HTMLDivElement>\n>;\n\n/**\n * MessageLoadingIndicator base component for showing loading state.\n * Renders three span elements with data-dot attributes for styling.\n */\nexport const MessageLoadingIndicator = React.forwardRef<\n  HTMLDivElement,\n  MessageLoadingIndicatorProps\n>(({ asChild, children, ...props }, ref) => {\n  const Comp = asChild ? Slot : \"div\";\n  return (\n    <Comp ref={ref} data-slot=\"loading-indicator\" {...props}>\n      {children ?? (\n        <>\n          <span data-dot=\"1\" />\n          <span data-dot=\"2\" />\n          <span data-dot=\"3\" />\n        </>\n      )}\n    </Comp>\n  );\n});\nMessageLoadingIndicator.displayName = \"Message.LoadingIndicator\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/rendered-component/rendered-component-canvas-button.tsx",
      "path": "src/components/tambo/base/message/rendered-component/rendered-component-canvas-button.tsx",
      "name": "rendered-component-canvas-button.tsx",
      "mimeType": "text/plain",
      "text": "import * as React from \"react\";\nimport { useMessageRootContext } from \"../root/message-root-context\";\n\nexport type MessageRenderedComponentCanvasButtonProps =\n  React.ButtonHTMLAttributes<HTMLButtonElement>;\n\nexport const MessageRenderedComponentCanvasButton = React.forwardRef<\n  HTMLButtonElement,\n  MessageRenderedComponentCanvasButtonProps\n>(({ children, ...props }, ref) => {\n  const { message } = useMessageRootContext();\n  const [canvasExists, setCanvasExists] = React.useState(false);\n\n  // Check if canvas exists on mount and window resize\n  React.useEffect(() => {\n    const checkCanvasExists = () => {\n      const canvas = document.querySelector('[data-canvas-space=\"true\"]');\n      setCanvasExists(!!canvas);\n    };\n\n    checkCanvasExists();\n    window.addEventListener(\"resize\", checkCanvasExists);\n    return () => window.removeEventListener(\"resize\", checkCanvasExists);\n  }, []);\n\n  const onShowInCanvas = React.useCallback(() => {\n    if (typeof window !== \"undefined\") {\n      window.dispatchEvent(\n        new CustomEvent(\"tambo:showComponent\", {\n          detail: {\n            messageId: message.id,\n            component: message.renderedComponent,\n          },\n        }),\n      );\n    }\n  }, [message.id, message.renderedComponent]);\n\n  if (!canvasExists) return null;\n\n  return (\n    <button\n      ref={ref}\n      onClick={onShowInCanvas}\n      data-slot=\"rendered-component-canvas-button\"\n      {...props}\n    >\n      {children}\n    </button>\n  );\n});\nMessageRenderedComponentCanvasButton.displayName =\n  \"Message.RenderedComponentCanvasButton\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/rendered-component/rendered-component-content.tsx",
      "path": "src/components/tambo/base/message/rendered-component/rendered-component-content.tsx",
      "name": "rendered-component-content.tsx",
      "mimeType": "text/plain",
      "text": "import * as React from \"react\";\nimport { useMessageRootContext } from \"../root/message-root-context\";\n\nexport const MessageRenderedComponentContent = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>((props, ref) => {\n  const { message } = useMessageRootContext();\n\n  if (!message.renderedComponent) {\n    return null;\n  }\n\n  return (\n    <div ref={ref} data-slot=\"message-rendered-component-content\" {...props}>\n      {message.renderedComponent}\n    </div>\n  );\n});\nMessageRenderedComponentContent.displayName =\n  \"Message.RenderedComponentContent\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/rendered-component/rendered-component.tsx",
      "path": "src/components/tambo/base/message/rendered-component/rendered-component.tsx",
      "name": "rendered-component.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useMessageRootContext } from \"../root/message-root-context\";\n\nexport interface MessageRenderedComponentProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n}\n\n/**\n * RenderedComponent base for displaying AI-generated components.\n * Only renders for assistant messages with a renderedComponent.\n */\nexport const MessageRenderedComponent = React.forwardRef<\n  HTMLDivElement,\n  MessageRenderedComponentProps\n>(({ asChild, children, ...props }, ref) => {\n  const { message, role } = useMessageRootContext();\n\n  if (\n    !message.renderedComponent ||\n    role !== \"assistant\" ||\n    message.isCancelled\n  ) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp ref={ref} data-slot=\"message-rendered-component-area\" {...props}>\n      {children}\n    </Comp>\n  );\n});\nMessageRenderedComponent.displayName = \"Message.RenderedComponent\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/root/message-root-context.tsx",
      "path": "src/components/tambo/base/message/root/message-root-context.tsx",
      "name": "message-root-context.tsx",
      "mimeType": "text/plain",
      "text": "import { TamboThreadMessage } from \"@tambo-ai/react\";\nimport React from \"react\";\n\n/**\n * Context value shared among Message primitive sub-components.\n */\ninterface MessageRootContextValue {\n  role: \"user\" | \"assistant\";\n  message: TamboThreadMessage;\n  isLoading?: boolean;\n}\n\nconst MessageRootContext = React.createContext<MessageRootContextValue | null>(\n  null,\n);\n\n/**\n * Hook to access the message context.\n * @returns The message context value\n * @throws Error if used outside of Message.Root component\n */\nfunction useMessageRootContext(): MessageRootContextValue {\n  const context = React.useContext(MessageRootContext);\n  if (!context) {\n    throw new Error(\n      \"React UI Base: MessageRootContext is missing. Message parts must be used within <Message.Root>\",\n    );\n  }\n  return context;\n}\n\nexport { MessageRootContext, useMessageRootContext };\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/message/root/message-root.tsx",
      "path": "src/components/tambo/base/message/root/message-root.tsx",
      "name": "message-root.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport { TamboThreadMessage } from \"@tambo-ai/react\";\nimport * as React from \"react\";\nimport { BaseProps } from \"../../types/component-render-or-children\";\nimport { MessageRootContext } from \"./message-root-context\";\n\nexport type MessageRootProps = BaseProps<\n  React.HTMLAttributes<HTMLDivElement> & {\n    /** The role of the message sender ('user' or 'assistant'). */\n    role: \"user\" | \"assistant\";\n    /** The full Tambo thread message object. */\n    message: TamboThreadMessage;\n    /** Optional flag to indicate if the message is in a loading state. */\n    isLoading?: boolean;\n  }\n>;\n\n/**\n * Root primitive for a message component.\n * Provides context for child components and applies data attributes.\n * Renders nothing for tool response messages.\n */\nexport const MessageRoot = React.forwardRef<HTMLDivElement, MessageRootProps>(\n  function MessageRoot(\n    { children, role, message, isLoading, asChild, ...props },\n    ref,\n  ) {\n    const contextValue = React.useMemo(\n      () => ({ role, isLoading, message }),\n      [role, isLoading, message],\n    );\n\n    // Don't render tool response messages as they're shown in tool call dropdowns\n    if (message.role === \"tool\") {\n      return null;\n    }\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <MessageRootContext.Provider value={contextValue}>\n        <Comp\n          ref={ref}\n          data-slot=\"message-root\"\n          data-message-role={role}\n          data-message-id={message.id}\n          {...props}\n        >\n          {children}\n        </Comp>\n      </MessageRootContext.Provider>\n    );\n  },\n);\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/content/reasoning-info-content.tsx",
      "path": "src/components/tambo/base/reasoning-info/content/reasoning-info-content.tsx",
      "name": "reasoning-info-content.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BaseProps } from \"../../types/component-render-or-children\";\nimport { useReasoningInfoRootContext } from \"../root/reasoning-info-context\";\n\nexport type ReasoningInfoContentProps = BaseProps<\n  React.HTMLAttributes<HTMLDivElement> & {\n    /** Force visibility regardless of expanded state (for custom animations). */\n    forceMount?: boolean;\n  }\n>;\n\n/**\n * Collapsible content area for reasoning details.\n * Includes a ref for auto-scrolling behavior.\n */\nexport const ReasoningInfoContent = React.forwardRef<\n  HTMLDivElement,\n  ReasoningInfoContentProps\n>(({ asChild, forceMount, children, ...props }, ref) => {\n  const { isExpanded, detailsId, scrollContainerRef } =\n    useReasoningInfoRootContext();\n\n  // Combine refs\n  const combinedRef = React.useCallback(\n    (node: HTMLDivElement | null) => {\n      (\n        scrollContainerRef as React.MutableRefObject<HTMLDivElement | null>\n      ).current = node;\n      if (typeof ref === \"function\") {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    },\n    [ref, scrollContainerRef],\n  );\n\n  if (!forceMount && !isExpanded) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={combinedRef}\n      id={detailsId}\n      data-slot=\"reasoning-info-content\"\n      data-state={isExpanded ? \"open\" : \"closed\"}\n      {...props}\n    >\n      {children}\n    </Comp>\n  );\n});\nReasoningInfoContent.displayName = \"ReasoningInfo.Content\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/index.tsx",
      "path": "src/components/tambo/base/reasoning-info/index.tsx",
      "name": "index.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { ReasoningInfoContent } from \"./content/reasoning-info-content\";\nimport { ReasoningInfoRoot } from \"./root/reasoning-info-root\";\nimport { ReasoningInfoStatusText } from \"./status-text/reasoning-info-status-text\";\nimport { ReasoningInfoSteps } from \"./steps/reasoning-info-steps\";\nimport { ReasoningInfoTrigger } from \"./trigger/reasoning-info-trigger\";\n\nexport const ReasoningInfo = {\n  Root: ReasoningInfoRoot,\n  Trigger: ReasoningInfoTrigger,\n  StatusText: ReasoningInfoStatusText,\n  Content: ReasoningInfoContent,\n  Steps: ReasoningInfoSteps,\n};\n\nexport type { ReasoningInfoContentProps } from \"./content/reasoning-info-content\";\nexport type { ReasoningInfoRootProps } from \"./root/reasoning-info-root\";\nexport type { ReasoningInfoStatusTextProps } from \"./status-text/reasoning-info-status-text\";\nexport type {\n  ReasoningInfoStepsProps,\n  ReasoningInfoStepsRenderFunctionProps,\n} from \"./steps/reasoning-info-steps\";\nexport type { ReasoningInfoTriggerProps } from \"./trigger/reasoning-info-trigger\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/root/reasoning-info-context.tsx",
      "path": "src/components/tambo/base/reasoning-info/root/reasoning-info-context.tsx",
      "name": "reasoning-info-context.tsx",
      "mimeType": "text/plain",
      "text": "import type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport * as React from \"react\";\n\ninterface ReasoningInfoRootContextValue {\n  isExpanded: boolean;\n  setIsExpanded: (expanded: boolean) => void;\n  detailsId: string;\n  isLoading: boolean | undefined;\n  message: TamboThreadMessage;\n  reasoning: string[];\n  reasoningDurationMS: number | undefined;\n  statusText: string;\n  scrollContainerRef: React.RefObject<HTMLDivElement | null>;\n}\n\nexport const ReasoningInfoRootContext =\n  React.createContext<ReasoningInfoRootContextValue | null>(null);\n\n/**\n * Hook to access the reasoning info context.\n * @returns The reasoning info context value\n * @throws Error if used outside of ReasoningInfo.Root\n */\nexport function useReasoningInfoRootContext(): ReasoningInfoRootContextValue {\n  const context = React.useContext(ReasoningInfoRootContext);\n  if (!context) {\n    throw new Error(\n      \"React UI Base: ReasoningInfoRootContext is missing. ReasoningInfo parts must be used within <ReasoningInfo.Root>\",\n    );\n  }\n  return context;\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/root/reasoning-info-root.tsx",
      "path": "src/components/tambo/base/reasoning-info/root/reasoning-info-root.tsx",
      "name": "reasoning-info-root.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport { TamboThreadMessage } from \"@tambo-ai/react\";\nimport { checkHasContent } from \"@/lib/thread-hooks\";\nimport * as React from \"react\";\nimport { ReasoningInfoRootContext } from \"./reasoning-info-context\";\n\n/**\n * Formats the reasoning duration in a human-readable format.\n * Converts milliseconds to an appropriate time unit (seconds, minutes, or hours).\n *\n * @param durationMS - The duration in milliseconds\n * @returns The formatted duration string (e.g., \"Thought for 5 seconds\")\n */\nexport function formatReasoningDuration(durationMS: number): string {\n  const seconds = Math.floor(Math.max(0, durationMS) / 1000);\n  const minutes = Math.floor(seconds / 60);\n  const hours = Math.floor(minutes / 60);\n\n  if (seconds < 1) return \"Thought for less than 1 second\";\n  if (seconds < 60)\n    return `Thought for ${seconds} ${seconds === 1 ? \"second\" : \"seconds\"}`;\n  if (minutes < 60)\n    return `Thought for ${minutes} ${minutes === 1 ? \"minute\" : \"minutes\"}`;\n  return `Thought for ${hours} ${hours === 1 ? \"hour\" : \"hours\"}`;\n}\n\nfunction getStatusText(\n  isLoading: boolean | undefined,\n  reasoningDurationMS: number | undefined,\n): string {\n  if (isLoading) {\n    return \"Thinking\";\n  }\n  if (reasoningDurationMS) {\n    return formatReasoningDuration(reasoningDurationMS);\n  }\n  return \"Done Thinking\";\n}\n\nexport interface ReasoningInfoRootProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n  /** Default expanded state. Defaults to true. */\n  defaultExpanded?: boolean;\n  /** Whether to auto-collapse when content arrives. Defaults to true. */\n  autoCollapse?: boolean;\n  /** The full Tambo thread message object. */\n  message: TamboThreadMessage;\n  /** Optional flag to indicate if the reasoning info is in a loading state. */\n  isLoading?: boolean;\n}\n\n/**\n * Root primitive for reasoning info.\n * Provides context for child components. Returns null if no reasoning data.\n */\nexport const ReasoningInfoRoot = React.forwardRef<\n  HTMLDivElement,\n  ReasoningInfoRootProps\n>(\n  (\n    {\n      asChild,\n      message,\n      isLoading,\n      defaultExpanded = true,\n      autoCollapse = true,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);\n    const detailsId = React.useId();\n    const scrollContainerRef = React.useRef<HTMLDivElement>(null);\n\n    const hasReasoning = !!message.reasoning?.length;\n    const statusText = getStatusText(isLoading, message.reasoningDurationMS);\n\n    const contextValue = React.useMemo(\n      () => ({\n        isExpanded,\n        setIsExpanded,\n        detailsId,\n        isLoading,\n        message,\n        reasoning: message.reasoning ?? [],\n        reasoningDurationMS: message.reasoningDurationMS,\n        statusText,\n        scrollContainerRef,\n      }),\n      [isExpanded, detailsId, isLoading, message, statusText],\n    );\n\n    // Auto-collapse when content arrives and reasoning is not loading\n    React.useEffect(() => {\n      if (autoCollapse && checkHasContent(message.content) && !isLoading) {\n        setIsExpanded(false);\n      }\n    }, [message.content, isLoading, autoCollapse]);\n\n    // Auto-scroll to bottom when reasoning content changes\n    React.useEffect(() => {\n      if (scrollContainerRef.current && isExpanded && message.reasoning) {\n        const scroll = () => {\n          if (scrollContainerRef.current) {\n            scrollContainerRef.current.scrollTo({\n              top: scrollContainerRef.current.scrollHeight,\n              behavior: \"smooth\",\n            });\n          }\n        };\n\n        if (isLoading) {\n          requestAnimationFrame(scroll);\n        } else {\n          const timeoutId = setTimeout(scroll, 50);\n          return () => clearTimeout(timeoutId);\n        }\n      }\n    }, [message.reasoning, isExpanded, isLoading]);\n\n    // Only show if there's reasoning data\n    if (!hasReasoning) {\n      return null;\n    }\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <ReasoningInfoRootContext.Provider value={contextValue}>\n        <Comp ref={ref} data-slot=\"reasoning-info\" {...props}>\n          {children}\n        </Comp>\n      </ReasoningInfoRootContext.Provider>\n    );\n  },\n);\nReasoningInfoRoot.displayName = \"ReasoningInfo.Root\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/status-text/reasoning-info-status-text.tsx",
      "path": "src/components/tambo/base/reasoning-info/status-text/reasoning-info-status-text.tsx",
      "name": "reasoning-info-status-text.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { useReasoningInfoRootContext } from \"../root/reasoning-info-context\";\n\nexport interface ReasoningInfoStatusTextRenderProps {\n  text: string;\n  isLoading: boolean | undefined;\n  stepCount: number;\n}\n\nexport type ReasoningInfoStatusTextProps =\n  BasePropsWithChildrenOrRenderFunction<\n    React.HTMLAttributes<HTMLSpanElement>,\n    ReasoningInfoStatusTextRenderProps\n  >;\n\n/**\n * Displays the reasoning status text.\n */\nexport const ReasoningInfoStatusText = React.forwardRef<\n  HTMLSpanElement,\n  ReasoningInfoStatusTextProps\n>(({ asChild, ...props }, ref) => {\n  const { statusText, isLoading, reasoning } = useReasoningInfoRootContext();\n\n  const Comp = asChild ? Slot : \"span\";\n\n  const renderProps: ReasoningInfoStatusTextRenderProps = {\n    text: statusText,\n    isLoading,\n    stepCount: reasoning.length,\n  };\n\n  const { content, componentProps } = useRender(props, renderProps);\n  const fallback = `${statusText} ${reasoning.length > 1 ? `(${reasoning.length} steps)` : \"\"}`;\n\n  return (\n    <Comp\n      ref={ref}\n      data-slot=\"reasoning-info-status-text\"\n      data-loading={isLoading || undefined}\n      {...componentProps}\n    >\n      {content ?? fallback}\n    </Comp>\n  );\n});\nReasoningInfoStatusText.displayName = \"ReasoningInfo.StatusText\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/steps/reasoning-info-steps.tsx",
      "path": "src/components/tambo/base/reasoning-info/steps/reasoning-info-steps.tsx",
      "name": "reasoning-info-steps.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { useReasoningInfoRootContext } from \"../root/reasoning-info-context\";\n\nexport interface ReasoningInfoStepsRenderFunctionProps {\n  steps: string[];\n  showStepNumbers: boolean;\n}\n\nexport type ReasoningInfoStepsProps = BasePropsWithChildrenOrRenderFunction<\n  React.HTMLAttributes<HTMLDivElement>,\n  ReasoningInfoStepsRenderFunctionProps\n>;\n\n/**\n * Provides reasoning steps data for rendering.\n */\nexport const ReasoningInfoSteps = React.forwardRef<\n  HTMLDivElement,\n  ReasoningInfoStepsProps\n>(({ asChild, ...props }, ref) => {\n  const { reasoning } = useReasoningInfoRootContext();\n\n  const Comp = asChild ? Slot : \"div\";\n\n  const { content, componentProps } = useRender(props, {\n    steps: reasoning,\n    showStepNumbers: reasoning.length > 1,\n  });\n\n  if (!content) return null;\n\n  return (\n    <Comp ref={ref} data-slot=\"reasoning-info-steps\" {...componentProps}>\n      {content}\n    </Comp>\n  );\n});\nReasoningInfoSteps.displayName = \"ReasoningInfo.Steps\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/reasoning-info/trigger/reasoning-info-trigger.tsx",
      "path": "src/components/tambo/base/reasoning-info/trigger/reasoning-info-trigger.tsx",
      "name": "reasoning-info-trigger.tsx",
      "mimeType": "text/plain",
      "text": "import { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BaseProps } from \"../../types/component-render-or-children\";\nimport { useReasoningInfoRootContext } from \"../root/reasoning-info-context\";\n\nexport type ReasoningInfoTriggerProps = BaseProps<\n  React.ButtonHTMLAttributes<HTMLButtonElement>\n>;\n\n/**\n * Trigger button for expanding/collapsing reasoning details.\n */\nexport const ReasoningInfoTrigger = React.forwardRef<\n  HTMLButtonElement,\n  ReasoningInfoTriggerProps\n>(({ asChild, onClick, children, ...props }, ref) => {\n  const { isExpanded, setIsExpanded, detailsId } =\n    useReasoningInfoRootContext();\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    setIsExpanded(!isExpanded);\n    onClick?.(e);\n  };\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      aria-expanded={isExpanded}\n      aria-controls={detailsId}\n      onClick={handleClick}\n      data-slot=\"reasoning-info-trigger\"\n      data-state={isExpanded ? \"open\" : \"closed\"}\n      {...props}\n    >\n      {children}\n    </Comp>\n  );\n});\nReasoningInfoTrigger.displayName = \"ReasoningInfo.Trigger\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/content/toolcall-info-content.tsx",
      "path": "src/components/tambo/base/toolcall-info/content/toolcall-info-content.tsx",
      "name": "toolcall-info-content.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoContentProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n  /** Force visibility regardless of expanded state (for custom animations). */\n  forceMount?: boolean;\n}\n\n/**\n * Collapsible content area for toolcall details.\n */\nexport const ToolcallInfoContent = React.forwardRef<\n  HTMLDivElement,\n  ToolcallInfoContentProps\n>(({ asChild, forceMount, children, ...props }, ref) => {\n  const { isExpanded, detailsId } = useToolcallInfoContext();\n\n  if (!forceMount && !isExpanded) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp\n      ref={ref}\n      id={detailsId}\n      data-slot=\"toolcall-info-content\"\n      data-state={isExpanded ? \"open\" : \"closed\"}\n      {...props}\n    >\n      {children}\n    </Comp>\n  );\n});\nToolcallInfoContent.displayName = \"ToolcallInfo.Content\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/index.tsx",
      "path": "src/components/tambo/base/toolcall-info/index.tsx",
      "name": "index.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { ToolcallInfoContent } from \"./content/toolcall-info-content\";\nimport { ToolcallInfoParameters } from \"./parameters/toolcall-info-parameters\";\nimport { ToolcallInfoResult } from \"./result/toolcall-info-result\";\nimport { ToolcallInfoRoot } from \"./root/toolcall-info-root\";\nimport { ToolcallInfoStatusIcon } from \"./status-icon/toolcall-info-status-icon\";\nimport { ToolcallInfoStatusText } from \"./status-text/toolcall-info-status-text\";\nimport { ToolcallInfoToolName } from \"./tool-name/toolcall-info-tool-name\";\nimport { ToolcallInfoTrigger } from \"./trigger/toolcall-info-trigger\";\n\n/**\n * ToolcallInfo namespace containing all toolcall info base components.\n */\nconst ToolcallInfo = {\n  Root: ToolcallInfoRoot,\n  Trigger: ToolcallInfoTrigger,\n  Content: ToolcallInfoContent,\n  StatusIcon: ToolcallInfoStatusIcon,\n  StatusText: ToolcallInfoStatusText,\n  ToolName: ToolcallInfoToolName,\n  Parameters: ToolcallInfoParameters,\n  Result: ToolcallInfoResult,\n};\n\nexport type { ToolcallInfoContentProps } from \"./content/toolcall-info-content\";\nexport type {\n  ToolcallInfoParametersProps,\n  ToolcallInfoParametersRenderProps,\n} from \"./parameters/toolcall-info-parameters\";\nexport type {\n  ToolcallInfoResultProps,\n  ToolcallInfoResultRenderProps,\n} from \"./result/toolcall-info-result\";\nexport type { ToolcallInfoRootProps } from \"./root/toolcall-info-root\";\nexport type {\n  ToolcallInfoStatusIconProps,\n  ToolcallInfoStatusIconRenderProps,\n  ToolStatus as ToolcallInfoToolStatus,\n} from \"./status-icon/toolcall-info-status-icon\";\nexport type { ToolcallInfoStatusTextProps } from \"./status-text/toolcall-info-status-text\";\nexport type {\n  ToolcallInfoToolNameProps,\n  ToolcallInfoToolNameRenderProps,\n} from \"./tool-name/toolcall-info-tool-name\";\nexport type { ToolcallInfoTriggerProps } from \"./trigger/toolcall-info-trigger\";\n\nexport { ToolcallInfo };\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/parameters/toolcall-info-parameters.tsx",
      "path": "src/components/tambo/base/toolcall-info/parameters/toolcall-info-parameters.tsx",
      "name": "toolcall-info-parameters.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { keyifyParameters } from \"../root/keyify-parameters\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoParametersRenderProps {\n  parameters: Record<string, unknown> | undefined;\n  parametersString: string;\n}\n\nexport type ToolcallInfoParametersProps = BasePropsWithChildrenOrRenderFunction<\n  React.HTMLAttributes<HTMLSpanElement>,\n  ToolcallInfoParametersRenderProps\n>;\n\n/**\n * Displays the tool parameters.\n */\nexport const ToolcallInfoParameters = React.forwardRef<\n  HTMLSpanElement,\n  ToolcallInfoParametersProps\n>(({ asChild, ...props }, ref) => {\n  const { toolCallRequest } = useToolcallInfoContext();\n\n  const keyifiedParams = keyifyParameters(toolCallRequest?.parameters);\n\n  const Comp = asChild ? Slot : \"span\";\n\n  const { content, componentProps } = useRender(props, {\n    parameters: keyifiedParams,\n    parametersString: JSON.stringify(keyifiedParams, null, 2),\n  });\n  return (\n    <Comp ref={ref} data-slot=\"toolcall-info-parameters\" {...componentProps}>\n      {content}\n    </Comp>\n  );\n});\nToolcallInfoParameters.displayName = \"ToolcallInfo.Parameters\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/result/toolcall-info-result.tsx",
      "path": "src/components/tambo/base/toolcall-info/result/toolcall-info-result.tsx",
      "name": "toolcall-info-result.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport * as React from \"react\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoResultRenderProps {\n  content: TamboThreadMessage[\"content\"] | null;\n  hasResult: boolean;\n}\n\nexport interface ToolcallInfoResultProps extends Omit<\n  React.HTMLAttributes<HTMLDivElement>,\n  \"children\"\n> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n  /** Render prop for custom result rendering. */\n  children?: (props: ToolcallInfoResultRenderProps) => React.ReactNode;\n}\n\n/**\n * Displays the tool result from the associated tool response.\n */\nexport const ToolcallInfoResult = React.forwardRef<\n  HTMLDivElement,\n  ToolcallInfoResultProps\n>(({ asChild, children, ...props }, ref) => {\n  const { associatedToolResponse } = useToolcallInfoContext();\n\n  if (!associatedToolResponse) {\n    return null;\n  }\n\n  const Comp = asChild ? Slot : \"div\";\n\n  return (\n    <Comp ref={ref} data-slot=\"toolcall-info-result\" {...props}>\n      {children?.({\n        content: associatedToolResponse.content,\n        hasResult: !!associatedToolResponse.content,\n      })}\n    </Comp>\n  );\n});\nToolcallInfoResult.displayName = \"ToolcallInfo.Result\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/root/get-tool-call-request.ts",
      "path": "src/components/tambo/base/toolcall-info/root/get-tool-call-request.ts",
      "name": "get-tool-call-request.ts",
      "mimeType": "text/plain",
      "text": "import type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport type TamboAI from \"@tambo-ai/typescript-sdk\";\n\n/**\n * Get the tool call request from the message, or the component tool call request\n * @param message - The message to get the tool call request from\n * @returns The tool call request\n */\nexport function getToolCallRequest(\n  message: TamboThreadMessage,\n): TamboAI.ToolCallRequest | undefined {\n  return message.toolCallRequest ?? message.component?.toolCallRequest;\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/root/get-tool-status-message.ts",
      "path": "src/components/tambo/base/toolcall-info/root/get-tool-status-message.ts",
      "name": "get-tool-status-message.ts",
      "mimeType": "text/plain",
      "text": "import type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport { getToolCallRequest } from \"./get-tool-call-request\";\n\n/**\n * Gets the status message for a tool call.\n * Returns the custom status message if available, otherwise generates a default one.\n * @param message - The thread message containing the tool call\n * @param isLoading - Whether the tool call is still in progress\n * @returns The status message string, or null if not a tool call message\n */\nexport function getToolStatusMessage(\n  message: TamboThreadMessage,\n  isLoading: boolean | undefined,\n): string | null {\n  if (message.role !== \"assistant\" || !getToolCallRequest(message)) {\n    return null;\n  }\n\n  const toolCallMessage = isLoading\n    ? `Calling ${getToolCallRequest(message)?.toolName ?? \"tool\"}`\n    : `Called ${getToolCallRequest(message)?.toolName ?? \"tool\"}`;\n  const toolStatusMessage = isLoading\n    ? message.component?.statusMessage\n    : message.component?.completionStatusMessage;\n  return toolStatusMessage ?? toolCallMessage;\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/root/keyify-parameters.ts",
      "path": "src/components/tambo/base/toolcall-info/root/keyify-parameters.ts",
      "name": "keyify-parameters.ts",
      "mimeType": "text/plain",
      "text": "import type TamboAI from \"@tambo-ai/typescript-sdk\";\n\n/**\n * Converts tool call parameters from an array format to an object format.\n * Maps each parameter's name to its value for easier consumption.\n * @param parameters - Array of tool call parameters\n * @returns Object with parameter names as keys and values as values\n */\nexport function keyifyParameters(\n  parameters: TamboAI.ToolCallParameter[] | undefined,\n): Record<string, unknown> | undefined {\n  if (!parameters) return;\n  return Object.fromEntries(\n    parameters.map((p) => [p.parameterName, p.parameterValue]),\n  );\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/root/toolcall-info-context.tsx",
      "path": "src/components/tambo/base/toolcall-info/root/toolcall-info-context.tsx",
      "name": "toolcall-info-context.tsx",
      "mimeType": "text/plain",
      "text": "import type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport type TamboAI from \"@tambo-ai/typescript-sdk\";\nimport * as React from \"react\";\n\nexport interface ToolcallInfoContextValue {\n  isExpanded: boolean;\n  setIsExpanded: (expanded: boolean) => void;\n  toolCallRequest: TamboAI.ToolCallRequest | undefined;\n  hasToolError: boolean;\n  toolStatusMessage: string;\n  associatedToolResponse: TamboThreadMessage | null;\n  detailsId: string;\n  isLoading: boolean | undefined;\n  message: TamboThreadMessage;\n}\n\nexport const ToolcallInfoContext =\n  React.createContext<ToolcallInfoContextValue | null>(null);\n\n/**\n * Hook to access the toolcall info context.\n * @returns The toolcall info context value\n * @throws Error if used outside of ToolcallInfo.Root\n */\nexport function useToolcallInfoContext(): ToolcallInfoContextValue {\n  const context = React.useContext(ToolcallInfoContext);\n  if (!context) {\n    throw new Error(\n      \"React UI Base: ToolcallInfoContext is missing. ToolcallInfo parts must be used within <ToolcallInfo.Root>\",\n    );\n  }\n  return context;\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/root/toolcall-info-root.tsx",
      "path": "src/components/tambo/base/toolcall-info/root/toolcall-info-root.tsx",
      "name": "toolcall-info-root.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport { useTambo } from \"@tambo-ai/react\";\nimport * as React from \"react\";\nimport { BaseProps } from \"../../types/component-render-or-children\";\nimport { getToolCallRequest } from \"./get-tool-call-request\";\nimport { getToolStatusMessage } from \"./get-tool-status-message\";\nimport { ToolcallInfoContext } from \"./toolcall-info-context\";\n\nexport type ToolcallInfoRootProps = BaseProps<\n  React.HTMLAttributes<HTMLDivElement> & {\n    /** Default expanded state. */\n    defaultExpanded?: boolean;\n    /** Whether the tool call is in a loading state. */\n    isLoading?: boolean;\n    /** The full Tambo thread message object. */\n    message: TamboThreadMessage;\n  }\n>;\n\n/**\n * Root component for toolcall info.\n * Provides context for child components. Returns null if not an assistant message with tool call.\n */\nexport const ToolcallInfoRoot = React.forwardRef<\n  HTMLDivElement,\n  ToolcallInfoRootProps\n>(\n  (\n    {\n      asChild,\n      message,\n      isLoading,\n      defaultExpanded = false,\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const [isExpanded, setIsExpanded] = React.useState(defaultExpanded);\n    const { thread } = useTambo();\n    const detailsId = React.useId();\n\n    const associatedToolResponse = React.useMemo(() => {\n      if (!thread?.messages) return null;\n      const currentMessageIndex = thread.messages.findIndex(\n        (m: TamboThreadMessage) => m.id === message.id,\n      );\n      if (currentMessageIndex === -1) return null;\n      for (let i = currentMessageIndex + 1; i < thread.messages.length; i++) {\n        const nextMessage = thread.messages[i];\n        if (nextMessage.role === \"tool\") {\n          return nextMessage;\n        }\n        if (\n          nextMessage.role === \"assistant\" &&\n          getToolCallRequest(nextMessage)\n        ) {\n          break;\n        }\n      }\n      return null;\n    }, [message, thread?.messages]);\n\n    const toolCallRequest = getToolCallRequest(message);\n    const isToolCallMessage = message.role === \"assistant\" && !!toolCallRequest;\n    const hasToolError = !!message.error;\n    // getToolStatusMessage returns null only for non-assistant messages or missing toolCallRequest,\n    // so provide a fallback for cases where it's not a tool call message\n    const toolStatusMessage = getToolStatusMessage(message, isLoading) ?? \"\";\n\n    const contextValue = React.useMemo(\n      () => ({\n        isExpanded,\n        setIsExpanded,\n        toolCallRequest,\n        hasToolError,\n        toolStatusMessage,\n        associatedToolResponse,\n        detailsId,\n        isLoading,\n        message,\n      }),\n      [\n        isExpanded,\n        toolCallRequest,\n        hasToolError,\n        toolStatusMessage,\n        associatedToolResponse,\n        detailsId,\n        isLoading,\n        message,\n      ],\n    );\n\n    if (!isToolCallMessage) {\n      return null;\n    }\n\n    const Comp = asChild ? Slot : \"div\";\n\n    return (\n      <ToolcallInfoContext.Provider value={contextValue}>\n        <Comp ref={ref} data-slot=\"toolcall-info\" {...props}>\n          {children}\n        </Comp>\n      </ToolcallInfoContext.Provider>\n    );\n  },\n);\nToolcallInfoRoot.displayName = \"ToolcallInfo.Root\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/status-icon/toolcall-info-status-icon.tsx",
      "path": "src/components/tambo/base/toolcall-info/status-icon/toolcall-info-status-icon.tsx",
      "name": "toolcall-info-status-icon.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport type ToolStatus = \"error\" | \"loading\" | \"success\";\n\nfunction getToolStatus(\n  hasToolError: boolean,\n  isLoading: boolean | undefined,\n): ToolStatus {\n  if (hasToolError) return \"error\";\n  if (isLoading) return \"loading\";\n  return \"success\";\n}\n\nexport interface ToolcallInfoStatusIconRenderProps {\n  status: ToolStatus;\n}\n\nexport type ToolcallInfoStatusIconProps = BasePropsWithChildrenOrRenderFunction<\n  React.HTMLAttributes<HTMLSpanElement>,\n  ToolcallInfoStatusIconRenderProps\n>;\n\n/**\n * Status icon component. Provides status data for custom rendering.\n */\nexport const ToolcallInfoStatusIcon = React.forwardRef<\n  HTMLSpanElement,\n  ToolcallInfoStatusIconProps\n>(({ asChild, ...props }, ref) => {\n  const { hasToolError, isLoading } = useToolcallInfoContext();\n\n  const status = getToolStatus(hasToolError, isLoading);\n\n  const Comp = asChild ? Slot : \"span\";\n\n  const { content, componentProps } = useRender(props, { status });\n\n  return (\n    <Comp\n      ref={ref}\n      data-slot=\"toolcall-info-status-icon\"\n      data-status={status}\n      {...componentProps}\n    >\n      {content}\n    </Comp>\n  );\n});\nToolcallInfoStatusIcon.displayName = \"ToolcallInfo.StatusIcon\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/status-text/toolcall-info-status-text.tsx",
      "path": "src/components/tambo/base/toolcall-info/status-text/toolcall-info-status-text.tsx",
      "name": "toolcall-info-status-text.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoStatusTextProps extends React.HTMLAttributes<HTMLSpanElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n}\n\n/**\n * Displays the tool status message text.\n */\nexport const ToolcallInfoStatusText = React.forwardRef<\n  HTMLSpanElement,\n  ToolcallInfoStatusTextProps\n>(({ asChild, children, ...props }, ref) => {\n  const { toolStatusMessage } = useToolcallInfoContext();\n\n  const Comp = asChild ? Slot : \"span\";\n\n  return (\n    <Comp ref={ref} data-slot=\"toolcall-info-status-text\" {...props}>\n      {children ?? toolStatusMessage}\n    </Comp>\n  );\n});\nToolcallInfoStatusText.displayName = \"ToolcallInfo.StatusText\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/tool-name/toolcall-info-tool-name.tsx",
      "path": "src/components/tambo/base/toolcall-info/tool-name/toolcall-info-tool-name.tsx",
      "name": "toolcall-info-tool-name.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../../types/component-render-or-children\";\nimport { useRender } from \"../../use-render/use-render\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoToolNameRenderProps {\n  toolName?: string;\n}\n\nexport type ToolcallInfoToolNameProps = BasePropsWithChildrenOrRenderFunction<\n  React.HTMLAttributes<HTMLSpanElement>,\n  ToolcallInfoToolNameRenderProps\n>;\n\n/**\n * Displays the tool name.\n */\nexport const ToolcallInfoToolName = React.forwardRef<\n  HTMLSpanElement,\n  ToolcallInfoToolNameProps\n>(({ asChild, ...props }, ref) => {\n  const { toolCallRequest } = useToolcallInfoContext();\n\n  const Comp = asChild ? Slot : \"span\";\n\n  const { content, componentProps } = useRender(props, {\n    toolName: toolCallRequest?.toolName,\n  });\n\n  return (\n    <Comp ref={ref} data-slot=\"toolcall-info-tool-name\" {...componentProps}>\n      {content}\n    </Comp>\n  );\n});\nToolcallInfoToolName.displayName = \"ToolcallInfo.ToolName\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/toolcall-info/trigger/toolcall-info-trigger.tsx",
      "path": "src/components/tambo/base/toolcall-info/trigger/toolcall-info-trigger.tsx",
      "name": "toolcall-info-trigger.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { Slot } from \"@radix-ui/react-slot\";\nimport * as React from \"react\";\nimport { useToolcallInfoContext } from \"../root/toolcall-info-context\";\n\nexport interface ToolcallInfoTriggerProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n}\n\n/**\n * Trigger button for expanding/collapsing toolcall details.\n */\nexport const ToolcallInfoTrigger = React.forwardRef<\n  HTMLButtonElement,\n  ToolcallInfoTriggerProps\n>(({ asChild, onClick, children, ...props }, ref) => {\n  const { isExpanded, setIsExpanded, detailsId } = useToolcallInfoContext();\n\n  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {\n    setIsExpanded(!isExpanded);\n    onClick?.(e);\n  };\n\n  const Comp = asChild ? Slot : \"button\";\n\n  return (\n    <Comp\n      ref={ref}\n      type=\"button\"\n      aria-expanded={isExpanded}\n      aria-controls={detailsId}\n      onClick={handleClick}\n      data-slot=\"toolcall-info-trigger\"\n      data-state={isExpanded ? \"open\" : \"closed\"}\n      {...props}\n    >\n      {children}\n    </Comp>\n  );\n});\nToolcallInfoTrigger.displayName = \"ToolcallInfo.Trigger\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/types/component-render-or-children.ts",
      "path": "src/components/tambo/base/types/component-render-or-children.ts",
      "name": "component-render-or-children.ts",
      "mimeType": "text/plain",
      "text": "import * as React from \"react\";\n\ntype ComponentRenderFn<Props> = (props: Props) => React.ReactNode;\n\ntype PropsWithRenderFunction<\n  ComponentProps = unknown,\n  RenderPropProps = never,\n> = ComponentProps & {\n  render?: ComponentRenderFn<RenderPropProps>;\n};\n\nexport type BaseProps<ComponentProps> = ComponentProps & {\n  /** When true, renders as a Slot, merging props into the child element. */\n  asChild?: boolean;\n};\n\nexport type PropsWithChildrenOrRenderFunction<\n  ComponentProps,\n  RenderPropProps = never,\n> =\n  | React.PropsWithChildren<ComponentProps>\n  | PropsWithRenderFunction<ComponentProps, RenderPropProps>;\n\nexport type BasePropsWithChildrenOrRenderFunction<\n  ComponentProps,\n  RenderPropProps = never,\n> = PropsWithChildrenOrRenderFunction<\n  BaseProps<ComponentProps>,\n  RenderPropProps\n>;\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/base/use-render/use-render.ts",
      "path": "src/components/tambo/base/use-render/use-render.ts",
      "name": "use-render.ts",
      "mimeType": "text/plain",
      "text": "import React from \"react\";\nimport { BasePropsWithChildrenOrRenderFunction } from \"../types/component-render-or-children\";\n\nfunction useRender<RenderFunctionProps>(\n  props: BasePropsWithChildrenOrRenderFunction<unknown, RenderFunctionProps>,\n  renderFunctionProps: RenderFunctionProps,\n): {\n  content: React.ReactNode;\n  componentProps: Omit<typeof props, \"children\" | \"render\">;\n} {\n  if (\"render\" in props && typeof props.render === \"function\") {\n    const { render, ...rest } = props;\n    return { content: render(renderFunctionProps), componentProps: rest };\n  }\n\n  if (\"children\" in props) {\n    const { children, ...rest } = props;\n    return { content: children, componentProps: rest };\n  }\n\n  return { content: null, componentProps: props };\n}\n\nexport { useRender };\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/control-bar.tsx",
      "path": "src/components/tambo/control-bar.tsx",
      "name": "control-bar.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport * as React from \"react\";\nimport { Dialog } from \"radix-ui\";\nimport { useTambo } from \"@tambo-ai/react\";\nimport { cn } from \"@/lib/utils\";\nimport type { VariantProps } from \"class-variance-authority\";\nimport type { messageVariants } from \"@/components/tambo/message\";\nimport {\n  MessageInput,\n  MessageInputTextarea,\n  MessageInputToolbar,\n  MessageInputSubmitButton,\n  MessageInputError,\n  MessageInputFileButton,\n  MessageInputMcpPromptButton,\n  MessageInputMcpResourceButton,\n  // MessageInputMcpConfigButton,\n} from \"@/components/tambo/message-input\";\nimport {\n  ThreadContent,\n  ThreadContentMessages,\n} from \"@/components/tambo/thread-content\";\nimport { ScrollableMessageContainer } from \"@/components/tambo/scrollable-message-container\";\n\n/**\n * Props for the ControlBar component\n * @interface\n * @extends React.HTMLAttributes<HTMLDivElement>\n */\nexport interface ControlBarProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Keyboard shortcut for toggling the control bar (default: \"mod+k\") */\n  hotkey?: string;\n  /**\n   * Controls the visual styling of messages in the thread.\n   * Possible values include: \"default\", \"compact\", etc.\n   * These values are defined in messageVariants from \"@/components/tambo/message\".\n   * @example variant=\"compact\"\n   */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n}\n\n/**\n * A floating control bar component for quick access to chat functionality\n * @component\n * @example\n * ```tsx\n * <ControlBar\n *   hotkey=\"mod+k\"\n *   className=\"custom-styles\"\n * />\n * ```\n */\nexport const ControlBar = React.forwardRef<HTMLDivElement, ControlBarProps>(\n  ({ className, hotkey = \"mod+k\", variant, ...props }, ref) => {\n    const [open, setOpen] = React.useState(false);\n    const isMac =\n      typeof navigator !== \"undefined\" && navigator.platform.startsWith(\"Mac\");\n    const { thread } = useTambo();\n\n    React.useEffect(() => {\n      const down = (e: KeyboardEvent) => {\n        const [modifier, key] = hotkey.split(\"+\");\n        const isModifierPressed =\n          modifier === \"mod\" ? e.metaKey || e.ctrlKey : false;\n        if (e.key === key && isModifierPressed) {\n          e.preventDefault();\n          setOpen((open) => !open);\n        }\n      };\n      document.addEventListener(\"keydown\", down);\n      return () => document.removeEventListener(\"keydown\", down);\n    }, [hotkey, setOpen]);\n\n    return (\n      <Dialog.Root open={open} onOpenChange={setOpen}>\n        <Dialog.Trigger asChild>\n          <button className=\"fixed bottom-4 right-4 bg-background/50 backdrop-blur-sm border rounded-lg px-3 py-1.5 text-xs text-muted-foreground hover:bg-accent/50 transition-colors\">\n            Talk to AI (\n            <span suppressHydrationWarning>\n              {hotkey.replace(\"mod\", isMac ? \"\" : \"Ctrl\")}\n            </span>\n            )\n          </button>\n        </Dialog.Trigger>\n        <Dialog.Portal>\n          <Dialog.Overlay className=\"fixed inset-0 bg-black/40\" />\n          <Dialog.Content\n            ref={ref}\n            className={cn(\n              \"fixed top-1/4 left-1/2 -translate-x-1/2 w-[440px] rounded-lg shadow-lg transition-all duration-200 outline-none\",\n              className,\n            )}\n            {...props}\n          >\n            <Dialog.Title className=\"sr-only\">Control Bar</Dialog.Title>\n            <div className=\"flex flex-col gap-3\">\n              <div className=\"bg-background border rounded-lg p-3 flex items-center justify-between gap-4\">\n                <div className=\"flex-1\">\n                  <MessageInput>\n                    <MessageInputTextarea />\n                    <MessageInputToolbar>\n                      <MessageInputFileButton />\n                      <MessageInputMcpPromptButton />\n                      <MessageInputMcpResourceButton />\n                      {/* Uncomment this to enable client-side MCP config modal button */}\n                      {/* <MessageInputMcpConfigButton /> */}\n                      <MessageInputSubmitButton />\n                    </MessageInputToolbar>\n                    <MessageInputError />\n                  </MessageInput>\n                </div>\n              </div>\n              {thread?.messages?.length > 0 && (\n                <ScrollableMessageContainer className=\"bg-background border rounded-lg p-4 max-h-[500px]\">\n                  <ThreadContent variant={variant}>\n                    <ThreadContentMessages />\n                  </ThreadContent>\n                </ScrollableMessageContainer>\n              )}\n            </div>\n          </Dialog.Content>\n        </Dialog.Portal>\n      </Dialog.Root>\n    );\n  },\n);\nControlBar.displayName = \"ControlBar\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/dictation-button.tsx",
      "path": "src/components/tambo/dictation-button.tsx",
      "name": "dictation-button.tsx",
      "mimeType": "text/plain",
      "text": "import { Tooltip } from \"@/components/tambo/message-suggestions\";\nimport { useTamboThreadInput, useTamboVoice } from \"@tambo-ai/react\";\nimport { Loader2Icon, Mic, Square } from \"lucide-react\";\nimport React, { useEffect, useRef } from \"react\";\n\n/**\n * Button for dictating speech into the message input.\n */\nexport default function DictationButton() {\n  const {\n    startRecording,\n    stopRecording,\n    isRecording,\n    isTranscribing,\n    transcript,\n    transcriptionError,\n  } = useTamboVoice();\n  const { setValue } = useTamboThreadInput();\n  const lastProcessedTranscriptRef = useRef<string>(\"\");\n\n  const handleStartRecording = () => {\n    lastProcessedTranscriptRef.current = \"\";\n    startRecording();\n  };\n\n  const handleStopRecording = () => {\n    stopRecording();\n  };\n\n  useEffect(() => {\n    if (transcript && transcript !== lastProcessedTranscriptRef.current) {\n      lastProcessedTranscriptRef.current = transcript;\n      setValue((prev) => prev + \" \" + transcript);\n    }\n  }, [transcript, setValue]);\n\n  if (isTranscribing) {\n    return (\n      <div className=\"p-2 rounded-md\">\n        <Loader2Icon className=\"h-5 w-5 animate-spin\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex flex-row items-center gap-2\">\n      <span className=\"text-sm text-red-500\">{transcriptionError}</span>\n      {isRecording ? (\n        <Tooltip content=\"Stop\">\n          <button\n            type=\"button\"\n            onClick={handleStopRecording}\n            aria-label=\"Stop dictation\"\n            className=\"p-2 rounded-md cursor-pointer hover:bg-muted\"\n          >\n            <Square className=\"h-4 w-4 text-red-500 fill-current animate-pulse\" />\n          </button>\n        </Tooltip>\n      ) : (\n        <Tooltip content=\"Dictate\">\n          <button\n            type=\"button\"\n            onClick={handleStartRecording}\n            aria-label=\"Start dictation\"\n            className=\"p-2 rounded-md cursor-pointer hover:bg-muted\"\n          >\n            <Mic className=\"h-5 w-5\" />\n          </button>\n        </Tooltip>\n      )}\n    </div>\n  );\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/elicitation-ui.tsx",
      "path": "src/components/tambo/elicitation-ui.tsx",
      "name": "elicitation-ui.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport {\n  type TamboElicitationRequest,\n  type TamboElicitationResponse,\n} from \"@tambo-ai/react/mcp\";\nimport * as React from \"react\";\nimport { useMemo, useState } from \"react\";\n\ntype FieldSchema =\n  TamboElicitationRequest[\"requestedSchema\"][\"properties\"][string];\n\n/**\n * Props for individual field components\n */\ninterface FieldProps {\n  name: string;\n  schema: FieldSchema;\n  value: unknown;\n  onChange: (value: unknown) => void;\n  required: boolean;\n  autoFocus?: boolean;\n  validationError?: string | null;\n}\n\n/**\n * Boolean field component - renders yes/no buttons\n */\nconst BooleanField: React.FC<FieldProps> = ({\n  name,\n  schema,\n  value,\n  onChange,\n  required,\n  autoFocus,\n}) => {\n  const boolValue = value as boolean | undefined;\n\n  return (\n    <div className=\"space-y-2\">\n      <label className=\"text-sm font-medium text-foreground\">\n        {schema.description ?? name}\n        {required && <span className=\"text-destructive ml-1\">*</span>}\n      </label>\n      <div className=\"flex gap-2\">\n        <button\n          type=\"button\"\n          autoFocus={autoFocus}\n          onClick={() => onChange(true)}\n          className={cn(\n            \"flex-1 px-4 py-2 rounded-lg border transition-colors\",\n            boolValue === true\n              ? \"bg-accent text-accent-foreground border-accent\"\n              : \"bg-background border-border hover:bg-muted\",\n          )}\n        >\n          Yes\n        </button>\n        <button\n          type=\"button\"\n          onClick={() => onChange(false)}\n          className={cn(\n            \"flex-1 px-4 py-2 rounded-lg border transition-colors\",\n            boolValue === false\n              ? \"bg-accent text-accent-foreground border-accent\"\n              : \"bg-background border-border hover:bg-muted\",\n          )}\n        >\n          No\n        </button>\n      </div>\n    </div>\n  );\n};\n\n/**\n * Enum field component - renders button for each choice\n */\nconst EnumField: React.FC<FieldProps> = ({\n  name,\n  schema,\n  value,\n  onChange,\n  required,\n  autoFocus,\n}) => {\n  if (schema.type !== \"string\" || !(\"enum\" in schema)) {\n    return null;\n  }\n  const options = schema.enum ?? [];\n  const optionNames =\n    \"enumNames\" in schema ? (schema.enumNames ?? []) : options;\n  const stringValue = value as string | undefined;\n\n  return (\n    <div className=\"space-y-2\">\n      <label className=\"text-sm font-medium text-foreground\">\n        {schema.description ?? name}\n        {required && <span className=\"text-destructive ml-1\">*</span>}\n      </label>\n      <div className=\"flex flex-wrap gap-2\">\n        {options.map((option, index) => (\n          <button\n            key={option}\n            type=\"button\"\n            autoFocus={autoFocus && index === 0}\n            onClick={() => onChange(option)}\n            className={cn(\n              \"px-4 py-2 rounded-lg border transition-colors\",\n              stringValue === option\n                ? \"bg-accent text-accent-foreground border-accent\"\n                : \"bg-background border-border hover:bg-muted\",\n            )}\n          >\n            {optionNames[index] ?? option}\n          </button>\n        ))}\n      </div>\n    </div>\n  );\n};\n\n/**\n * String field component - renders text input with validation\n */\nconst StringField: React.FC<FieldProps> = ({\n  name,\n  schema,\n  value,\n  onChange,\n  required,\n  autoFocus,\n  validationError,\n}) => {\n  const inputId = React.useId();\n\n  if (schema.type !== \"string\") {\n    return null;\n  }\n  const stringValue = (value as string | undefined) ?? \"\";\n\n  // Map JSON Schema format to HTML5 input type\n  const getInputType = (): string => {\n    const format = \"format\" in schema ? schema.format : undefined;\n    switch (format) {\n      case \"email\":\n        return \"email\";\n      case \"uri\":\n        return \"url\";\n      case \"date\":\n        return \"date\";\n      case \"date-time\":\n        return \"datetime-local\";\n      default:\n        return \"text\";\n    }\n  };\n\n  const inputType = getInputType();\n  const hasError = !!validationError;\n  const errorId = `${inputId}-error`;\n\n  return (\n    <div className=\"space-y-2\">\n      <label htmlFor={inputId} className=\"text-sm font-medium text-foreground\">\n        {schema.description ?? name}\n        {required && <span className=\"text-destructive ml-1\">*</span>}\n      </label>\n      <input\n        id={inputId}\n        type={inputType}\n        autoFocus={autoFocus}\n        value={stringValue}\n        onChange={(e) => onChange(e.target.value)}\n        className={cn(\n          \"w-full px-3 py-2 rounded-lg border bg-background text-foreground focus:outline-none focus:ring-2\",\n          hasError\n            ? \"border-destructive focus:ring-destructive\"\n            : \"border-border focus:ring-accent\",\n        )}\n        placeholder={schema.description ?? name}\n        minLength={\"minLength\" in schema ? schema.minLength : undefined}\n        maxLength={\"maxLength\" in schema ? schema.maxLength : undefined}\n        required={required}\n        aria-invalid={hasError || undefined}\n        aria-describedby={hasError ? errorId : undefined}\n      />\n      {validationError && (\n        <p id={errorId} className=\"text-xs text-destructive\" aria-live=\"polite\">\n          {validationError}\n        </p>\n      )}\n    </div>\n  );\n};\n\n/**\n * Number field component - renders number input with validation\n */\nconst NumberField: React.FC<FieldProps> = ({\n  name,\n  schema,\n  value,\n  onChange,\n  required,\n  autoFocus,\n  validationError,\n}) => {\n  const inputId = React.useId();\n\n  if (schema.type !== \"number\" && schema.type !== \"integer\") {\n    return null;\n  }\n  const numberSchema = schema;\n  const numberValue = value as number | undefined;\n  const hasError = !!validationError;\n  const errorId = `${inputId}-error`;\n\n  return (\n    <div className=\"space-y-2\">\n      <label htmlFor={inputId} className=\"text-sm font-medium text-foreground\">\n        {schema.description ?? name}\n        {required && <span className=\"text-destructive ml-1\">*</span>}\n      </label>\n      <input\n        id={inputId}\n        type=\"number\"\n        autoFocus={autoFocus}\n        value={numberValue ?? \"\"}\n        onChange={(e) => {\n          const { value, valueAsNumber } = e.currentTarget;\n          onChange(\n            value === \"\" || Number.isNaN(valueAsNumber)\n              ? undefined\n              : valueAsNumber,\n          );\n        }}\n        className={cn(\n          \"w-full px-3 py-2 rounded-lg border bg-background text-foreground focus:outline-none focus:ring-2\",\n          hasError\n            ? \"border-destructive focus:ring-destructive\"\n            : \"border-border focus:ring-accent\",\n        )}\n        placeholder={schema.description ?? name}\n        min={numberSchema.minimum}\n        max={numberSchema.maximum}\n        step={numberSchema.type === \"integer\" ? 1 : \"any\"}\n        required={required}\n        aria-invalid={hasError || undefined}\n        aria-describedby={hasError ? errorId : undefined}\n      />\n      {validationError && (\n        <p id={errorId} className=\"text-xs text-destructive\" aria-live=\"polite\">\n          {validationError}\n        </p>\n      )}\n    </div>\n  );\n};\n\n/**\n * Generic field component that renders the appropriate input based on schema type\n */\nconst Field: React.FC<FieldProps> = (props) => {\n  const { schema } = props;\n\n  if (schema.type === \"boolean\") {\n    return <BooleanField {...props} />;\n  }\n\n  if (schema.type === \"string\" && \"enum\" in schema) {\n    return <EnumField {...props} />;\n  }\n\n  if (schema.type === \"string\") {\n    return <StringField {...props} />;\n  }\n\n  if (schema.type === \"number\" || schema.type === \"integer\") {\n    return <NumberField {...props} />;\n  }\n\n  return null;\n};\n\n/**\n * Determines if the elicitation should use single-entry mode\n * (one field that is boolean or enum)\n */\nfunction isSingleEntryMode(request: TamboElicitationRequest): boolean {\n  const fields = Object.entries(request.requestedSchema.properties);\n\n  if (fields.length !== 1) {\n    return false;\n  }\n\n  const [, schema] = fields[0];\n\n  return (\n    schema.type === \"boolean\" || (schema.type === \"string\" && \"enum\" in schema)\n  );\n}\n\n/**\n * Unified validation function that returns both validity and a user-facing message.\n * Avoids drift between boolean validation and error computation.\n */\nfunction validateField(\n  value: unknown,\n  schema: FieldSchema,\n  required: boolean,\n): { valid: boolean; error: string | null } {\n  // Required\n  if (required && (value === undefined || value === \"\" || value === null)) {\n    return { valid: false, error: \"This field is required\" };\n  }\n\n  // If empty and not required, it's valid\n  if (!required && (value === undefined || value === \"\" || value === null)) {\n    return { valid: true, error: null };\n  }\n\n  // String validation\n  if (schema.type === \"string\") {\n    const stringSchema = schema;\n    const stringValue = String(value);\n\n    if (\n      \"minLength\" in stringSchema &&\n      stringSchema.minLength !== undefined &&\n      stringValue.length < stringSchema.minLength\n    ) {\n      return {\n        valid: false,\n        error: `Minimum length is ${stringSchema.minLength} characters`,\n      };\n    }\n\n    if (\n      \"maxLength\" in stringSchema &&\n      stringSchema.maxLength !== undefined &&\n      stringValue.length > stringSchema.maxLength\n    ) {\n      return {\n        valid: false,\n        error: `Maximum length is ${stringSchema.maxLength} characters`,\n      };\n    }\n\n    if (\"pattern\" in stringSchema && stringSchema.pattern) {\n      try {\n        const regex = new RegExp(stringSchema.pattern as string);\n        if (!regex.test(stringValue)) {\n          return {\n            valid: false,\n            error: \"Value does not match required pattern\",\n          };\n        }\n      } catch {\n        // Invalid regex pattern, skip validation\n      }\n    }\n\n    // Format validation\n    if (\"format\" in stringSchema && stringSchema.format) {\n      switch (stringSchema.format) {\n        case \"email\":\n          if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(stringValue)) {\n            return {\n              valid: false,\n              error: \"Please enter a valid email address\",\n            };\n          }\n          break;\n        case \"uri\":\n          try {\n            new URL(stringValue);\n          } catch {\n            return { valid: false, error: \"Please enter a valid URL\" };\n          }\n          break;\n      }\n    }\n  }\n\n  // Number validation\n  if (schema.type === \"number\" || schema.type === \"integer\") {\n    const numberSchema = schema;\n    const numberValue = Number(value);\n\n    if (Number.isNaN(numberValue)) {\n      return { valid: false, error: \"Please enter a valid number\" };\n    }\n\n    if (\n      numberSchema.minimum !== undefined &&\n      numberValue < numberSchema.minimum\n    ) {\n      return {\n        valid: false,\n        error: `Minimum value is ${numberSchema.minimum}`,\n      };\n    }\n\n    if (\n      numberSchema.maximum !== undefined &&\n      numberValue > numberSchema.maximum\n    ) {\n      return {\n        valid: false,\n        error: `Maximum value is ${numberSchema.maximum}`,\n      };\n    }\n\n    if (schema.type === \"integer\" && !Number.isInteger(numberValue)) {\n      return { valid: false, error: \"Please enter a whole number\" };\n    }\n  }\n\n  return { valid: true, error: null };\n}\n\n// Backwards-compatible helpers that delegate to the unified validator\nfunction getValidationError(\n  value: unknown,\n  schema: FieldSchema,\n  required: boolean,\n): string | null {\n  return validateField(value, schema, required).error;\n}\n\n/**\n * Props for the ElicitationUI component\n */\nexport interface ElicitationUIProps {\n  request: TamboElicitationRequest;\n  onResponse: (response: TamboElicitationResponse) => void;\n  className?: string;\n}\n\n/**\n * Main elicitation UI component\n * Handles both single-entry and multiple-entry modes\n */\nexport const ElicitationUI: React.FC<ElicitationUIProps> = ({\n  request,\n  onResponse,\n  className,\n}) => {\n  const singleEntry = isSingleEntryMode(request);\n  const fields = useMemo(\n\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/markdown-components.tsx",
      "path": "src/components/tambo/markdown-components.tsx",
      "name": "markdown-components.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport DOMPurify from \"dompurify\";\nimport hljs from \"highlight.js\";\nimport \"highlight.js/styles/github.css\";\nimport { Check, Copy, ExternalLink, X } from \"lucide-react\";\nimport * as React from \"react\";\n\n/**\n * Markdown Components for Streamdown\n *\n * This module provides customized components for rendering markdown content with syntax highlighting.\n * It uses highlight.js for code syntax highlighting and supports streaming content updates.\n *\n * @example\n * ```tsx\n * import { createMarkdownComponents } from './markdown-components';\n * import { Streamdown } from 'streamdown';\n *\n * const MarkdownRenderer = ({ content }) => {\n *   const components = createMarkdownComponents();\n *   return <Streamdown components={components}>{content}</Streamdown>;\n * };\n * ```\n */\n\n/**\n * Determines if a text block looks like code based on common code patterns\n * @param text - The text to analyze\n * @returns boolean indicating if the text appears to be code\n */\nconst looksLikeCode = (text: string): boolean => {\n  const codeIndicators = [\n    /^import\\s+/m,\n    /^function\\s+/m,\n    /^class\\s+/m,\n    /^const\\s+/m,\n    /^let\\s+/m,\n    /^var\\s+/m,\n    /[{}[\\]();]/,\n    /^\\s*\\/\\//m,\n    /^\\s*\\/\\*/m,\n    /=>/,\n    /^export\\s+/m,\n  ];\n  return codeIndicators.some((pattern) => pattern.test(text));\n};\n\n/**\n * Resource mention component that displays resource names.\n * Matches the styling from text-editor.tsx mention components.\n */\nfunction ResourceMention({ name, uri }: { name: string; uri: string }) {\n  return (\n    <span\n      className=\"mention resource inline-flex items-center rounded-md bg-muted px-2 py-0.5 text-xs font-medium text-muted-foreground cursor-default\"\n      data-resource-uri={uri}\n      title={uri}\n    >\n      @{name}\n    </span>\n  );\n}\n\n/**\n * Header component for code blocks with language display and copy functionality\n */\nconst CodeHeader = ({\n  language,\n  code,\n}: {\n  language?: string;\n  code?: string;\n}) => {\n  const [copied, setCopied] = React.useState(false);\n  const [error, setError] = React.useState(false);\n  const timeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const copyToClipboard = async () => {\n    if (!code) return;\n\n    // Clear any existing timeout to prevent race conditions\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n      timeoutRef.current = null;\n    }\n\n    try {\n      await navigator.clipboard.writeText(code);\n      setCopied(true);\n      setError(false);\n    } catch (err) {\n      console.error(\"Failed to copy code to clipboard:\", err);\n      setError(true);\n    }\n    timeoutRef.current = setTimeout(() => setError(false), 2000);\n  };\n\n  const Icon = React.useMemo(() => {\n    if (error) {\n      return <X className=\"size-4 text-red-500\" />;\n    }\n    if (copied) {\n      return <Check className=\"size-4 text-green-500\" />;\n    }\n    return <Copy className=\"size-4\" />;\n  }, [copied, error]);\n\n  return (\n    <div className=\"flex items-center justify-between gap-4 rounded-t-md bg-container px-4 py-2 text-sm font-semibold text-foreground\">\n      <span className=\"lowercase text-muted-foreground\">{language}</span>\n      <button\n        onClick={copyToClipboard}\n        className=\"p-1 rounded-md hover:bg-backdrop transition-colors cursor-pointer\"\n        title={error ? \"Failed to copy\" : \"Copy code\"}\n      >\n        {Icon}\n      </button>\n    </div>\n  );\n};\n\n/**\n * Creates a set of components for use with streamdown\n * @returns Components object for streamdown\n */\nexport const createMarkdownComponents = (): Record<\n  string,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  React.ComponentType<any>\n> => ({\n  code: function Code({ className, children, ...props }) {\n    const match = /language-(\\w+)/.exec(className ?? \"\");\n    const content = String(children).replace(/\\n$/, \"\");\n    const deferredContent = React.useDeferredValue(content);\n\n    const highlighted = React.useMemo(() => {\n      if (!match || !looksLikeCode(deferredContent)) return null;\n      try {\n        return hljs.highlight(deferredContent, { language: match[1] }).value;\n      } catch {\n        return deferredContent;\n      }\n    }, [deferredContent, match]);\n\n    if (match && looksLikeCode(content)) {\n      return (\n        <div className=\"relative border border-border rounded-md bg-muted max-w-[80ch] text-sm my-4\">\n          <CodeHeader language={match[1]} code={content} />\n          <div\n            className={cn(\n              \"overflow-x-auto rounded-b-md bg-background\",\n              \"[&::-webkit-scrollbar]:w-[6px]\",\n              \"[&::-webkit-scrollbar-thumb]:bg-muted-foreground/30 [&::-webkit-scrollbar-thumb]:rounded-md\",\n              \"[&::-webkit-scrollbar:horizontal]:h-[4px]\",\n            )}\n          >\n            <pre className=\"p-4 whitespace-pre\">\n              <code\n                className={className}\n                dangerouslySetInnerHTML={{\n                  __html: DOMPurify.sanitize(highlighted ?? content),\n                }}\n              />\n            </pre>\n          </div>\n        </div>\n      );\n    }\n\n    return (\n      <code\n        className={cn(\"bg-muted px-1.5 py-0.5 rounded text-sm\", className)}\n        {...props}\n      >\n        {children}\n      </code>\n    );\n  },\n\n  /**\n   * Paragraph component with minimal vertical margin\n   */\n  p: ({ children }) => <p className=\"my-0\">{children}</p>,\n\n  /**\n   * Heading 1 component with large text and proper spacing\n   * Used for main section headers\n   */\n  h1: ({ children }) => (\n    <h1 className=\"text-2xl font-bold mb-4 mt-6\">{children}</h1>\n  ),\n\n  /**\n   * Heading 2 component for subsection headers\n   * Slightly smaller than h1 with adjusted spacing\n   */\n  h2: ({ children }) => (\n    <h2 className=\"text-xl font-bold mb-3 mt-5\">{children}</h2>\n  ),\n\n  /**\n   * Heading 3 component for minor sections\n   * Used for smaller subdivisions within h2 sections\n   */\n  h3: ({ children }) => (\n    <h3 className=\"text-lg font-bold mb-2 mt-4\">{children}</h3>\n  ),\n\n  /**\n   * Heading 4 component for the smallest section divisions\n   * Maintains consistent text size with adjusted spacing\n   */\n  h4: ({ children }) => (\n    <h4 className=\"text-base font-bold mb-2 mt-3\">{children}</h4>\n  ),\n\n  /**\n   * Unordered list component with disc-style bullets\n   * Indented from the left margin\n   */\n  ul: ({ children }) => <ul className=\"list-disc pl-5\">{children}</ul>,\n\n  /**\n   * Ordered list component with decimal numbering\n   * Indented from the left margin\n   */\n  ol: ({ children }) => <ol className=\"list-decimal pl-5\">{children}</ol>,\n\n  /**\n   * List item component with normal line height\n   * Used within both ordered and unordered lists\n   */\n  li: ({ children }) => <li className=\"leading-normal\">{children}</li>,\n\n  /**\n   * Blockquote component for quoted content\n   * Features a left border and italic text with proper spacing\n   */\n  blockquote: ({ children }) => (\n    <blockquote className=\"border-l-4 border-muted pl-4 italic my-4\">\n      {children}\n    </blockquote>\n  ),\n\n  /**\n   * Anchor component for links\n   * Detects tambo-resource:// URIs and renders them as ResourceMention components.\n   * Regular links open in new tab with security attributes.\n   */\n  a: ({ href, children }) => {\n    // Check if href uses tambo-resource:// protocol to signal it's a resource\n    if (href?.startsWith(\"tambo-resource://\")) {\n      // Extract encoded URI (everything after tambo-resource://)\n      const encodedUri = href.slice(\"tambo-resource://\".length);\n      // Decode the URI\n      let uri: string;\n      try {\n        uri = decodeURIComponent(encodedUri);\n      } catch {\n        // If decoding fails, use the encoded version as fallback\n        uri = encodedUri;\n      }\n      // Extract name from children (link text)\n      // Handle different children types (string, number, array, etc.)\n      let name: string;\n      if (typeof children === \"string\") {\n        name = children;\n      } else if (typeof children === \"number\") {\n        name = String(children);\n      } else if (Array.isArray(children)) {\n        // If children is an array, join string elements\n        name = children\n          .map((child) =>\n            typeof child === \"string\" ? child : String(child ?? \"\"),\n          )\n          .join(\"\");\n      } else {\n        name = String(children ?? uri);\n      }\n      return <ResourceMention name={name || uri} uri={uri} />;\n    }\n\n    // Regular link rendering\n    return (\n      <a\n        href={href}\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        className=\"inline-flex items-center gap-1.5 text-foreground underline underline-offset-4 decoration-muted-foreground hover:text-foreground hover:decoration-foreground transition-colors\"\n      >\n        <span>{children}</span>\n        <ExternalLink className=\"w-3 h-3\" />\n      </a>\n    );\n  },\n\n  /**\n   * Horizontal rule component\n   * Creates a visual divider with proper spacing\n   */\n  hr: () => <hr className=\"my-4 border-muted\" />,\n\n  /**\n   * Table container component\n   * Handles overflow for wide tables with proper spacing\n   */\n  table: ({ children }) => (\n    <div className=\"overflow-x-auto my-4\">\n      <table className=\"min-w-full border border-border\">{children}</table>\n    </div>\n  ),\n\n  /**\n   * Table header cell component\n   * Features bold text and distinct background\n   */\n  th: ({ children }) => (\n    <th className=\"border border-border px-4 py-2 bg-muted font-semibold\">\n      {children}\n    </th>\n  ),\n\n  /**\n   * Table data cell component\n   * Consistent styling with header cells\n   */\n  td: ({ children }) => (\n    <td className=\"border border-border px-4 py-2\">{children}</td>\n  ),\n});\n\n/**\n * Pre-created markdown components instance for use across the application.\n */\nexport const markdownComponents = createMarkdownComponents();\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/mcp-components.tsx",
      "path": "src/components/tambo/mcp-components.tsx",
      "name": "mcp-components.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport {\n  Tooltip,\n  TooltipProvider,\n} from \"@/components/tambo/message-suggestions\";\nimport { cn } from \"@/lib/utils\";\nimport * as DropdownMenu from \"@radix-ui/react-dropdown-menu\";\nimport {\n  useTamboMcpPrompt,\n  useTamboMcpPromptList,\n  useTamboMcpResourceList,\n} from \"@tambo-ai/react/mcp\";\nimport { AlertCircle, AtSign, FileText, Search } from \"lucide-react\";\nimport * as React from \"react\";\n\n/**\n * Represents a single message content item from an MCP prompt.\n */\ninterface PromptMessageContent {\n  type?: string;\n  text?: string;\n}\n\n/**\n * Represents a single message from an MCP prompt.\n */\ninterface PromptMessage {\n  content?: PromptMessageContent;\n}\n\n/**\n * Validates that prompt data has a valid messages array structure.\n * @param promptData - The prompt data to validate\n * @returns true if the prompt data has valid messages, false otherwise\n */\nfunction isValidPromptData(\n  promptData: unknown,\n): promptData is { messages: PromptMessage[] } {\n  if (!promptData || typeof promptData !== \"object\") {\n    return false;\n  }\n\n  const data = promptData as { messages?: unknown };\n  if (!Array.isArray(data.messages)) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Safely extracts text content from prompt messages.\n * Handles malformed or missing content gracefully.\n * @param messages - Array of prompt messages\n * @returns Extracted text content joined by newlines\n */\nfunction extractPromptText(messages: PromptMessage[]): string {\n  return messages\n    .map((msg) => {\n      // Safely access nested properties\n      if (\n        msg?.content?.type === \"text\" &&\n        typeof msg.content.text === \"string\"\n      ) {\n        return msg.content.text;\n      }\n      return \"\";\n    })\n    .filter(Boolean)\n    .join(\"\\n\");\n}\n\n/**\n * Props for the McpPromptButton component.\n */\nexport interface McpPromptButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  /** Callback to insert text into the input */\n  onInsertText: (text: string) => void;\n  /** Current input value */\n  value: string;\n  /** Optional custom className */\n  className?: string;\n}\n\n/**\n * MCP Prompt picker button component for inserting prompts from MCP servers.\n * @component McpPromptButton\n * @example\n * ```tsx\n * <McpPromptButton\n *   value={inputValue}\n *   onInsertText={(text) => setInputValue(text)}\n * />\n * ```\n */\nexport const McpPromptButton = React.forwardRef<\n  HTMLButtonElement,\n  McpPromptButtonProps\n>(({ className, onInsertText, value, ...props }, ref) => {\n  const { data: promptList, isLoading } = useTamboMcpPromptList();\n  const [selectedPromptName, setSelectedPromptName] = React.useState<\n    string | null\n  >(null);\n  const [promptError, setPromptError] = React.useState<string | null>(null);\n  const { data: promptData, error: fetchError } = useTamboMcpPrompt(\n    selectedPromptName ?? \"\",\n  );\n\n  // When prompt data is fetched, validate and insert it into the input\n  React.useEffect(() => {\n    if (selectedPromptName && promptData) {\n      // Validate prompt data structure\n      if (!isValidPromptData(promptData)) {\n        setPromptError(\"Invalid prompt format received\");\n        setSelectedPromptName(null);\n        return;\n      }\n\n      // Extract text with safe access\n      const promptText = extractPromptText(promptData.messages);\n\n      if (!promptText) {\n        setPromptError(\"Prompt contains no text content\");\n        setSelectedPromptName(null);\n        return;\n      }\n\n      // Clear any previous errors\n      setPromptError(null);\n\n      // Insert the prompt text, appending to existing value if any\n      const newValue = value ? `${value}\\n\\n${promptText}` : promptText;\n      onInsertText(newValue);\n\n      // Reset the selected prompt\n      setSelectedPromptName(null);\n    }\n  }, [promptData, selectedPromptName, onInsertText, value]);\n\n  // Handle fetch errors\n  React.useEffect(() => {\n    if (fetchError) {\n      setPromptError(\"Failed to load prompt\");\n      setSelectedPromptName(null);\n    }\n  }, [fetchError]);\n\n  // Clear error after a delay\n  React.useEffect(() => {\n    if (promptError) {\n      const timer = setTimeout(() => setPromptError(null), 3000);\n      return () => clearTimeout(timer);\n    }\n  }, [promptError]);\n\n  // Only show button if prompts are available (hide during loading and when no prompts)\n  if (!promptList || promptList.length === 0) {\n    return null;\n  }\n\n  const buttonClasses = cn(\n    \"w-10 h-10 rounded-lg border border-border bg-background text-foreground transition-colors hover:bg-muted disabled:opacity-50 disabled:pointer-events-none flex items-center justify-center focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background\",\n    className,\n  );\n\n  return (\n    <TooltipProvider>\n      <Tooltip\n        content={promptError ?? \"Insert MCP Prompt\"}\n        side=\"top\"\n        className={cn(\n          \"bg-muted text-foreground\",\n          promptError && \"bg-destructive text-destructive-foreground\",\n        )}\n      >\n        <DropdownMenu.Root>\n          <DropdownMenu.Trigger asChild>\n            <button\n              ref={ref}\n              type=\"button\"\n              className={cn(\n                buttonClasses,\n                promptError && \"border-destructive text-destructive\",\n              )}\n              aria-label=\"Insert MCP Prompt\"\n              data-slot=\"mcp-prompt-button\"\n              {...props}\n            >\n              {promptError ? (\n                <AlertCircle className=\"w-4 h-4\" />\n              ) : (\n                <FileText className=\"w-4 h-4\" />\n              )}\n            </button>\n          </DropdownMenu.Trigger>\n          <DropdownMenu.Portal>\n            <DropdownMenu.Content\n              className=\"z-50 min-w-[200px] max-w-[300px] overflow-hidden rounded-md border border-border bg-popover p-1 text-popover-foreground shadow-md\"\n              side=\"top\"\n              align=\"start\"\n              sideOffset={5}\n            >\n              <PromptListContent\n                isLoading={isLoading}\n                promptList={promptList}\n                onSelectPrompt={setSelectedPromptName}\n              />\n            </DropdownMenu.Content>\n          </DropdownMenu.Portal>\n        </DropdownMenu.Root>\n      </Tooltip>\n    </TooltipProvider>\n  );\n});\nMcpPromptButton.displayName = \"McpPromptButton\";\n\n/**\n * Internal component to render prompt list content\n */\nfunction PromptListContent({\n  isLoading,\n  promptList,\n  onSelectPrompt,\n}: {\n  isLoading: boolean;\n  promptList:\n    | {\n        server: { url: string };\n        prompt: { name: string; description?: string };\n      }[]\n    | undefined;\n  onSelectPrompt: (name: string) => void;\n}) {\n  if (isLoading) {\n    return (\n      <DropdownMenu.Item\n        className=\"px-2 py-1.5 text-sm text-muted-foreground\"\n        disabled\n      >\n        Loading prompts...\n      </DropdownMenu.Item>\n    );\n  }\n  if (!promptList || promptList.length === 0) {\n    return (\n      <DropdownMenu.Item\n        className=\"px-2 py-1.5 text-sm text-muted-foreground\"\n        disabled\n      >\n        No prompts available\n      </DropdownMenu.Item>\n    );\n  }\n  return (\n    <>\n      {promptList.map((promptEntry) => (\n        <DropdownMenu.Item\n          key={`${promptEntry.server.url}-${promptEntry.prompt.name}`}\n          className=\"relative flex cursor-pointer select-none items-start flex-col rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\"\n          onSelect={() => {\n            onSelectPrompt(promptEntry.prompt.name);\n          }}\n        >\n          <span className=\"font-medium truncate max-w-full\">\n            {promptEntry.prompt.name}\n          </span>\n          {promptEntry.prompt.description && (\n            <span className=\"text-xs text-muted-foreground truncate max-w-full\">\n              {promptEntry.prompt.description}\n            </span>\n          )}\n        </DropdownMenu.Item>\n      ))}\n    </>\n  );\n}\n\n/**\n * Props for the ResourceCombobox internal component\n */\ninterface ResourceComboboxProps {\n  setIsOpen: (open: boolean) => void;\n  searchQuery: string;\n  setSearchQuery: (query: string) => void;\n  filteredResources: ReturnType<typeof useTamboMcpResourceList>[\"data\"];\n  isLoading: boolean;\n  onSelectResource: (id: string, label: string) => void;\n}\n\n/**\n * Internal combobox component for MCP resource selection with search functionality.\n * Not exported - only used within McpResourceButton.\n */\nconst ResourceCombobox: React.FC<ResourceComboboxProps> = ({\n  searchQuery,\n  setSearchQuery,\n  filteredResources,\n  isLoading,\n  onSelectResource,\n  setIsOpen,\n}) => {\n  return (\n    <DropdownMenu.Portal>\n      <DropdownMenu.Content\n        className=\"z-50 w-[400px] max-h-[400px] overflow-hidden rounded-md border border-border bg-popover text-popover-foreground shadow-md\"\n        side=\"top\"\n        align=\"start\"\n        sideOffset={5}\n        onCloseAutoFocus={(e) => {\n          // Prevent focus from moving when closing\n          e.preventDefault();\n        }}\n      >\n        {/* Search input */}\n        <div className=\"sticky top-0 bg-popover border-b border-border p-2 z-10\">\n          <div className=\"relative\">\n            <Search className=\"absolute left-2 top-1/2 transform -translate-y-1/2 w-4 h-4 text-muted-foreground pointer-events-none\" />\n            <input\n              type=\"text\"\n              placeholder=\"Search resources...\"\n              value={searchQuery}\n              onChange={(e) => setSearchQuery(e.target.value)}\n              className=\"w-full pl-8 pr-3 py-1.5 text-sm bg-background border border-border rounded-md focus:outline-none focus:ring-2 focus:ring-ring focus:border-transparent\"\n              onClick={(e) => e.stopPropagation()}\n              onKeyDown={(e) => {\n                // Prevent dropdown from closing on key events\n                e.stopPropagation();\n                if (e.key === \"Escape\") {\n                  setIsOpen(false);\n                }\n              }}\n            />\n          </div>\n        </div>\n\n        {/* Resource list */}\n        <div className=\"overflow-y-auto max-h-[320px] p-1\">\n          <ResourceListContent\n            isLoading={isLoading}\n            filteredResources={filteredResources}\n            searchQuery={searchQuery}\n            onSelectResource={onSelectResource}\n          />\n        </div>\n      </DropdownMenu.Content>\n    </DropdownMenu.Portal>\n  );\n};\n\n/**\n * Internal component to render resource list content\n */\nfunction ResourceListContent({\n  isLoading,\n  filteredResources,\n  searchQuery,\n  onSelectResource,\n}: {\n  isLoading: boolean;\n  filteredResources: ReturnType<typeof useTamboMcpResourceList>[\"data\"];\n  searchQuery: string;\n  onSelectResource: (id: string, label: string) => void;\n}) {\n  if (isLoading) {\n    return (\n      <div className=\"px-2 py-8 text-center text-sm text-muted-foreground\">\n        Loading resources...\n      </div>\n    );\n  }\n  if (!filteredResources || filteredResources.length === 0) {\n    return (\n      <div className=\"px-2 py-8 text-center text-sm text-muted-foreground\">\n        {searchQuery\n          ? `No resources matching \"${searchQuery}\"`\n          : \"No resources available\"}\n      </div>\n    );\n  }\n  return (\n    <>\n      {filteredResources.map((resourceEntry) => (\n        <DropdownMenu.Item\n          key={resourceEntry.resource.uri}\n          className=\"relative flex cursor-pointer select-none items-start flex-col rounded-sm px-2 py-2 text-sm outline-none hover:bg-accent hover:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground\"\n          onSelect={() => {\n            onSelectResource(\n              resourceEntry.resource.uri,\n              resourceEntry.resource.name || resourceEntry.resource.uri,\n            );\n          }}\n        >\n          <div className=\"flex items-start justify-between w-full gap-2\">\n            \n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/mcp-config-modal.tsx",
      "path": "src/components/tambo/mcp-config-modal.tsx",
      "name": "mcp-config-modal.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { createMarkdownComponents } from \"@/components/tambo/message\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuItem,\n  DropdownMenuTrigger,\n} from \"@radix-ui/react-dropdown-menu\";\nimport { type McpServerInfo, MCPTransport } from \"@tambo-ai/react\";\nimport { motion } from \"framer-motion\";\nimport { ChevronDown, Trash2, X } from \"lucide-react\";\nimport React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { Streamdown } from \"streamdown\";\n\n/**\n * Modal component for configuring client-side MCP (Model Context Protocol) servers.\n *\n * This component provides a user interface for managing MCP server connections that\n * will be used to extend the capabilities of the tambo application. The servers are\n * stored in browser localStorage and connected directly from the client-side.\n *\n * @param props - Component props\n * @param props.isOpen - Whether the modal is currently open/visible\n * @param props.onClose - Callback function called when the modal should be closed\n * @returns The modal component or null if not open\n */\nexport const McpConfigModal = ({\n  isOpen,\n  onClose,\n  className,\n}: {\n  isOpen: boolean;\n  onClose: () => void;\n  className?: string;\n}) => {\n  // Initialize from localStorage directly to avoid conflicts\n  const [mcpServers, setMcpServers] = React.useState<McpServerInfo[]>(() => {\n    if (typeof window === \"undefined\") return [];\n    try {\n      return JSON.parse(localStorage.getItem(\"mcp-servers\") ?? \"[]\");\n    } catch {\n      return [];\n    }\n  });\n  const [serverUrl, setServerUrl] = React.useState(\"\");\n  const [serverName, setServerName] = React.useState(\"\");\n  const [transportType, setTransportType] = React.useState<MCPTransport>(\n    MCPTransport.HTTP,\n  );\n  const [savedSuccess, setSavedSuccess] = React.useState(false);\n  const [showInstructions, setShowInstructions] = React.useState(false);\n\n  // Handle Escape key to close modal\n  React.useEffect(() => {\n    const handleEscapeKey = (event: KeyboardEvent) => {\n      if (event.key === \"Escape\") {\n        onClose();\n      }\n    };\n\n    if (isOpen) {\n      document.addEventListener(\"keydown\", handleEscapeKey);\n    }\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleEscapeKey);\n    };\n  }, [isOpen, onClose]);\n\n  // Save servers to localStorage when updated and emit events\n  React.useEffect(() => {\n    if (typeof window !== \"undefined\") {\n      localStorage.setItem(\"mcp-servers\", JSON.stringify(mcpServers));\n\n      // Emit custom event to notify other components in the same tab\n      window.dispatchEvent(\n        new CustomEvent(\"mcp-servers-updated\", {\n          detail: mcpServers,\n        }),\n      );\n\n      if (mcpServers.length > 0) {\n        setSavedSuccess(true);\n        const timer = setTimeout(() => setSavedSuccess(false), 2000);\n        return () => clearTimeout(timer);\n      }\n    }\n  }, [mcpServers]);\n\n  const addServer = (e: React.FormEvent) => {\n    e.preventDefault();\n    if (serverUrl.trim()) {\n      const serverConfig = {\n        url: serverUrl.trim(),\n        transport: transportType,\n        ...(serverName.trim() ? { name: serverName.trim() } : {}),\n      };\n      setMcpServers((prev) => [...prev, serverConfig]);\n\n      // Reset form fields\n      setServerUrl(\"\");\n      setServerName(\"\");\n      setTransportType(MCPTransport.HTTP);\n    }\n  };\n\n  const removeServer = (index: number) => {\n    setMcpServers((prev) => prev.filter((_, i) => i !== index));\n  };\n\n  // Helper function to get server display information\n  const getServerInfo = (server: McpServerInfo) => {\n    if (typeof server === \"string\") {\n      return { url: server, transport: \"HTTP (default)\", name: null };\n    } else {\n      return {\n        url: server.url,\n        transport: server.transport ?? \"HTTP (default)\",\n        name: server.name ?? null,\n      };\n    }\n  };\n\n  const handleBackdropClick = (e: React.MouseEvent) => {\n    // Close modal when clicking on backdrop (not on the modal content)\n    if (e.target === e.currentTarget) {\n      onClose();\n    }\n  };\n\n  const getTransportDisplayText = (transport: MCPTransport) => {\n    return transport === MCPTransport.HTTP ? \"HTTP (default)\" : \"SSE\";\n  };\n\n  if (!isOpen) return null;\n\n  const instructions = `\n###\n\nAfter configuring your MCP servers below, integrate them into your application.\n\n#### 1. Import the required hook\n\n\\`\\`\\`tsx\nimport { useMcpServers } from \"@/components/tambo/mcp-config-modal\";\n\\`\\`\\`\n\n#### 2. Load MCP servers and pass to TamboProvider:\n\n\\`\\`\\`tsx\nconst mcpServers = useMcpServers();\n\\`\\`\\`\n\n#### 3. Example implementation:\n\n\\`\\`\\`tsx\nfunction MyApp() {\n  const mcpServers = useMcpServers(); // Reactive - updates when servers change\n\n  return (\n    <TamboProvider\n      apiKey={apiKey}\n      components={components}\n      tools={tools}\n      mcpServers={mcpServers}\n    >\n      {/* Your app components */}\n    </TamboProvider>\n  );\n}\n\\`\\`\\`\n`;\n\n  const modalContent = (\n    <motion.div\n      className={cn(\n        \"fixed inset-0 bg-backdrop flex items-center justify-center z-50\",\n        className,\n      )}\n      onClick={handleBackdropClick}\n      initial={{ opacity: 0 }}\n      animate={{ opacity: 1 }}\n      transition={{ duration: 0.2 }}\n    >\n      <div className=\"bg-card rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto\">\n        <div className=\"flex items-center justify-between p-4\">\n          <h2 className=\"text-lg font-semibold\">MCP Server Configuration</h2>\n          <button\n            onClick={onClose}\n            className=\"hover:bg-muted rounded-lg transition-colors cursor-pointer\"\n            aria-label=\"Close modal\"\n          >\n            <X className=\"w-4 h-4\" />\n          </button>\n        </div>\n\n        {/* Content */}\n        <div className=\"px-4 pb-4\">\n          <div className=\"mb-6 bg-container border border-muted rounded-lg\">\n            <button\n              onClick={() => setShowInstructions(!showInstructions)}\n              className=\"w-full flex items-center justify-between p-2 hover:bg-muted transition-colors cursor-pointer\"\n              type=\"button\"\n            >\n              <span className=\"text-sm font-semibold text-foreground\">\n                Setup Instructions\n              </span>\n              <ChevronDown\n                className={`w-4 h-4 text-foreground transition-transform duration-200 ${\n                  showInstructions ? \"rotate-180\" : \"\"\n                }`}\n              />\n            </button>\n            {showInstructions && (\n              <motion.div\n                className=\"px-4 pb-4 border-t border-muted\"\n                initial={{ opacity: 0, y: 10 }}\n                animate={{ opacity: 1, y: 0 }}\n                transition={{ duration: 0.3 }}\n              >\n                <Streamdown components={createMarkdownComponents()}>\n                  {instructions}\n                </Streamdown>\n              </motion.div>\n            )}\n          </div>\n          {/* Description */}\n          <div className=\"mb-6\">\n            <p className=\"text-foreground mb-3 text-sm leading-relaxed\">\n              Configure{\" \"}\n              <span className=\"font-semibold text-foreground\">client-side</span>{\" \"}\n              MCP servers to extend the capabilities of your tambo application.\n              These servers will be connected{\" \"}\n              <i>\n                <b>from the browser</b>\n              </i>{\" \"}\n              and exposed as tools to tambo.\n            </p>\n          </div>\n\n          {/* Form */}\n          <form onSubmit={addServer} className=\"mb-8\">\n            <div className=\"space-y-4\">\n              {/* Server URL */}\n              <div>\n                <label\n                  htmlFor=\"server-url\"\n                  className=\"block text-sm font-semibold text-foreground mb-2\"\n                >\n                  Server URL\n                  <span className=\"text-muted-foreground font-normal ml-1\">\n                    (must be accessible from the browser)\n                  </span>\n                </label>\n                <input\n                  id=\"server-url\"\n                  type=\"url\"\n                  value={serverUrl}\n                  onChange={(e) => setServerUrl(e.target.value)}\n                  placeholder=\"https://your-mcp-server-url.com\"\n                  className=\"w-full px-3 py-2.5 border border-muted rounded-lg focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-150 text-sm\"\n                  required\n                />\n              </div>\n\n              {/* Server Name */}\n              <div>\n                <label\n                  htmlFor=\"server-name\"\n                  className=\"block text-sm font-semibold text-foreground mb-2\"\n                >\n                  Server Name\n                  <span className=\"text-muted-foreground font-normal ml-1\">\n                    (optional)\n                  </span>\n                </label>\n                <input\n                  id=\"server-name\"\n                  type=\"text\"\n                  value={serverName}\n                  onChange={(e) => setServerName(e.target.value)}\n                  placeholder=\"Custom server name\"\n                  className=\"w-full px-3 py-2.5 border border-muted rounded-lg focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent transition-all duration-150 text-sm\"\n                />\n              </div>\n\n              {/* Transport Type */}\n              <div>\n                <label className=\"block text-sm font-semibold text-foreground mb-2\">\n                  Transport Type\n                </label>\n                <DropdownMenu>\n                  <DropdownMenuTrigger asChild>\n                    <button\n                      type=\"button\"\n                      className=\"w-full px-3 py-2.5 border border-muted rounded-lg focus:outline-none focus:ring-2 focus:ring-primary focus:border-transparent bg-card text-foreground text-sm flex items-center justify-between hover:bg-muted-backdrop cursor-pointer transition-all duration-150\"\n                    >\n                      <span>{getTransportDisplayText(transportType)}</span>\n                      <ChevronDown className=\"w-4 h-4 text-foreground\" />\n                    </button>\n                  </DropdownMenuTrigger>\n                  <DropdownMenuContent\n                    className=\"w-full min-w-[200px] bg-card border border-muted rounded-lg shadow-lg z-50 py-1 animate-in fade-in-0 zoom-in-95 duration-100\"\n                    align=\"start\"\n                  >\n                    <DropdownMenuItem\n                      className=\"px-3 py-2 text-sm text-foreground hover:bg-muted-backdrop cursor-pointer focus:bg-muted-backdrop focus:outline-none\"\n                      onClick={() => setTransportType(MCPTransport.HTTP)}\n                    >\n                      HTTP (default)\n                    </DropdownMenuItem>\n                    <DropdownMenuItem\n                      className=\"px-3 py-2 text-sm text-foreground hover:bg-muted-backdrop cursor-pointer focus:bg-muted-backdrop focus:outline-none\"\n                      onClick={() => setTransportType(MCPTransport.SSE)}\n                    >\n                      SSE\n                    </DropdownMenuItem>\n                  </DropdownMenuContent>\n                </DropdownMenu>\n              </div>\n            </div>\n\n            <button\n              type=\"submit\"\n              className=\"mt-6 w-full px-4 py-2.5 bg-primary text-primary-foreground rounded-lg hover:bg-primary/90 focus:outline-none focus:ring-2 focus:ring-primary focus:ring-offset-2 cursor-pointer transition-all duration-150 font-medium\"\n            >\n              Add Server\n            </button>\n          </form>\n\n          {/* Success Message */}\n          {savedSuccess && (\n            <div className=\"mb-6 p-3 bg-green-50 border border-green-200 text-green-800 rounded-lg text-sm animate-in slide-in-from-top-1 duration-200\">\n              <di\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/message-generation-stage.tsx",
      "path": "src/components/tambo/message-generation-stage.tsx",
      "name": "message-generation-stage.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport { type GenerationStage, useTambo } from \"@tambo-ai/react\";\nimport { Loader2Icon } from \"lucide-react\";\nimport * as React from \"react\";\n\n/**\n * Represents the generation stage of a message\n * @property {string} className - Optional className for custom styling\n * @property {boolean} showLabel - Whether to show the label\n */\n\nexport interface GenerationStageProps extends React.HTMLAttributes<HTMLDivElement> {\n  showLabel?: boolean;\n}\n\nexport function MessageGenerationStage({\n  className,\n  showLabel = true,\n  ...props\n}: GenerationStageProps) {\n  const { thread, isIdle } = useTambo();\n  const stage = thread?.generationStage;\n\n  // Only render if we have a generation stage\n  if (!stage) {\n    return null;\n  }\n\n  // Map stage names to more user-friendly labels\n  const stageLabels: Record<GenerationStage, string> = {\n    IDLE: \"Idle\",\n    CHOOSING_COMPONENT: \"Choosing component\",\n    FETCHING_CONTEXT: \"Fetching context\",\n    HYDRATING_COMPONENT: \"Preparing component\",\n    STREAMING_RESPONSE: \"Generating response\",\n    COMPLETE: \"Complete\",\n    ERROR: \"Error\",\n    CANCELLED: \"Cancelled\",\n  };\n\n  const label =\n    stageLabels[stage] || stage.charAt(0).toUpperCase() + stage.slice(1);\n\n  if (isIdle) {\n    return null;\n  }\n\n  return (\n    <div\n      className={cn(\n        \"inline-flex items-center gap-2 px-2 py-1 text-xs rounded-md bg-transparent text-muted-foreground\",\n        className,\n      )}\n      {...props}\n    >\n      <Loader2Icon className=\"h-3 w-3 animate-spin\" />\n      {showLabel && <span>{label}</span>}\n    </div>\n  );\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/message-input.tsx",
      "path": "src/components/tambo/message-input.tsx",
      "name": "message-input.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { ElicitationUI } from \"@/components/tambo/elicitation-ui\";\nimport {\n  McpPromptButton,\n  McpResourceButton,\n} from \"@/components/tambo/mcp-components\";\nimport { McpConfigModal } from \"./mcp-config-modal\";\nimport {\n  Tooltip,\n  TooltipProvider,\n} from \"@/components/tambo/message-suggestions\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  useIsTamboTokenUpdating,\n  useTamboThread,\n  useTamboThreadInput,\n  type StagedImage,\n} from \"@tambo-ai/react\";\nimport {\n  useTamboElicitationContext,\n  useTamboMcpPrompt,\n  useTamboMcpPromptList,\n  useTamboMcpResourceList,\n  type TamboElicitationRequest,\n  type TamboElicitationResponse,\n} from \"@tambo-ai/react/mcp\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport {\n  ArrowUp,\n  AtSign,\n  FileText,\n  Image as ImageIcon,\n  Paperclip,\n  Square,\n  X,\n} from \"lucide-react\";\nimport * as React from \"react\";\nimport { useDebounce } from \"use-debounce\";\nimport {\n  getImageItems,\n  TextEditor,\n  type PromptItem,\n  type ResourceItem,\n  type TamboEditor,\n} from \"./text-editor\";\n\n// Lazy load DictationButton for code splitting (framework-agnostic alternative to next/dynamic)\n// eslint-disable-next-line @typescript-eslint/promise-function-async\nconst LazyDictationButton = React.lazy(() => import(\"./dictation-button\"));\n\n/**\n * Wrapper component that includes Suspense boundary for the lazy-loaded DictationButton.\n * This ensures the component can be safely used without requiring consumers to add their own Suspense.\n * Also handles SSR by only rendering on the client (DictationButton uses Web Audio APIs).\n */\nconst DictationButton = () => {\n  const [isMounted, setIsMounted] = React.useState(false);\n\n  React.useEffect(() => {\n    setIsMounted(true);\n  }, []);\n\n  if (!isMounted) {\n    return null;\n  }\n\n  return (\n    <React.Suspense fallback={null}>\n      <LazyDictationButton />\n    </React.Suspense>\n  );\n};\n\n/**\n * Provider interface for searching resources (for \"@\" mentions).\n * Empty query string \"\" should return all available resources.\n */\nexport interface ResourceProvider {\n  /** Search for resources matching the query */\n  search(query: string): Promise<ResourceItem[]>;\n}\n\n/**\n * Provider interface for searching and fetching prompts (for \"/\" commands).\n * Empty query string \"\" should return all available prompts.\n */\nexport interface PromptProvider {\n  /** Search for prompts matching the query */\n  search(query: string): Promise<PromptItem[]>;\n  /** Get the full prompt details including text by ID */\n  get(id: string): Promise<PromptItem>;\n}\n\n/**\n * Removes duplicate resource items based on ID.\n */\nconst dedupeResourceItems = (resourceItems: ResourceItem[]) => {\n  const seen = new Set<string>();\n  return resourceItems.filter((item) => {\n    if (seen.has(item.id)) return false;\n    seen.add(item.id);\n    return true;\n  });\n};\n\n/**\n * Filters resource items by query string.\n * Empty query returns all items.\n */\nconst filterResourceItems = (\n  resourceItems: ResourceItem[],\n  query: string,\n): ResourceItem[] => {\n  if (query === \"\") return resourceItems;\n\n  const normalizedQuery = query.toLocaleLowerCase();\n  return resourceItems.filter((item) =>\n    item.name.toLocaleLowerCase().includes(normalizedQuery),\n  );\n};\n\n/**\n * Filters prompt items by query string.\n * Empty query returns all items.\n */\nconst filterPromptItems = (\n  promptItems: PromptItem[],\n  query: string,\n): PromptItem[] => {\n  if (query === \"\") return promptItems;\n\n  const normalizedQuery = query.toLocaleLowerCase();\n  return promptItems.filter((item) =>\n    item.name.toLocaleLowerCase().includes(normalizedQuery),\n  );\n};\n\nconst EXTERNAL_SEARCH_DEBOUNCE_MS = 200;\n\n/**\n * Hook to get a combined resource list that merges MCP resources with an external provider.\n * Returns the combined, filtered resource items.\n *\n * @param externalProvider - Optional external resource provider\n * @param search - Search string to filter resources. For MCP servers, results are filtered locally.\n *                 For registry dynamic sources, the search is passed to listResources(search).\n */\nfunction useCombinedResourceList(\n  externalProvider: ResourceProvider | undefined,\n  search: string,\n): ResourceItem[] {\n  const { data: mcpResources } = useTamboMcpResourceList(search);\n  const [debouncedSearch] = useDebounce(search, EXTERNAL_SEARCH_DEBOUNCE_MS);\n\n  // Convert MCP resources to ResourceItems\n  const mcpItems: ResourceItem[] = React.useMemo(\n    () =>\n      mcpResources\n        ? (\n            mcpResources as {\n              resource: { uri: string; name?: string };\n            }[]\n          ).map((entry) => ({\n            // Use the full URI (already includes serverKey prefix from MCP hook)\n            // When inserted as @{id}, parseResourceReferences will strip serverKey before sending to backend\n            id: entry.resource.uri,\n            name: entry.resource.name ?? entry.resource.uri,\n            icon: React.createElement(AtSign, { className: \"w-4 h-4\" }),\n            componentData: { type: \"mcp-resource\", data: entry },\n          }))\n        : [],\n    [mcpResources],\n  );\n\n  // Track external provider results with state\n  const [externalItems, setExternalItems] = React.useState<ResourceItem[]>([]);\n\n  // Fetch external resources when search changes\n  React.useEffect(() => {\n    if (!externalProvider) {\n      setExternalItems([]);\n      return;\n    }\n\n    let cancelled = false;\n    externalProvider\n      .search(debouncedSearch)\n      .then((items) => {\n        if (!cancelled) {\n          setExternalItems(items);\n        }\n      })\n      .catch((error) => {\n        console.error(\"Failed to fetch external resources\", error);\n        if (!cancelled) {\n          setExternalItems([]);\n        }\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [externalProvider, debouncedSearch]);\n\n  // Combine and dedupe - MCP resources are already filtered by the hook\n  // External items need to be filtered locally\n  const combined = React.useMemo(() => {\n    const filteredExternal = filterResourceItems(externalItems, search);\n    return dedupeResourceItems([...mcpItems, ...filteredExternal]);\n  }, [mcpItems, externalItems, search]);\n\n  return combined;\n}\n\n/**\n * Hook to get a combined prompt list that merges MCP prompts with an external provider.\n * Returns the combined, filtered prompt items.\n *\n * @param externalProvider - Optional external prompt provider\n * @param search - Search string to filter prompts by name. MCP prompts are filtered via the hook.\n */\nfunction useCombinedPromptList(\n  externalProvider: PromptProvider | undefined,\n  search: string,\n): PromptItem[] {\n  // Pass search to MCP hook for filtering\n  const { data: mcpPrompts } = useTamboMcpPromptList(search);\n  const [debouncedSearch] = useDebounce(search, EXTERNAL_SEARCH_DEBOUNCE_MS);\n\n  // Convert MCP prompts to PromptItems (mark with mcp-prompt: prefix for special handling)\n  const mcpItems: PromptItem[] = React.useMemo(\n    () =>\n      mcpPrompts\n        ? (mcpPrompts as { prompt: { name: string } }[]).map((entry) => ({\n            id: `mcp-prompt:${entry.prompt.name}`,\n            name: entry.prompt.name,\n            icon: React.createElement(FileText, { className: \"w-4 h-4\" }),\n            text: \"\", // Text will be fetched when selected via useTamboMcpPrompt\n          }))\n        : [],\n    [mcpPrompts],\n  );\n\n  // Track external provider results with state\n  const [externalItems, setExternalItems] = React.useState<PromptItem[]>([]);\n\n  // Fetch external prompts when search changes\n  React.useEffect(() => {\n    if (!externalProvider) {\n      setExternalItems([]);\n      return;\n    }\n\n    let cancelled = false;\n    externalProvider\n      .search(debouncedSearch)\n      .then((items) => {\n        if (!cancelled) {\n          setExternalItems(items);\n        }\n      })\n      .catch((error) => {\n        console.error(\"Failed to fetch external prompts\", error);\n        if (!cancelled) {\n          setExternalItems([]);\n        }\n      });\n\n    return () => {\n      cancelled = true;\n    };\n  }, [externalProvider, debouncedSearch]);\n\n  // Combine - MCP prompts are already filtered by the hook\n  // External items need to be filtered locally\n  const combined = React.useMemo(() => {\n    const filteredExternal = filterPromptItems(externalItems, search);\n    return [...mcpItems, ...filteredExternal];\n  }, [mcpItems, externalItems, search]);\n\n  return combined;\n}\n\n/**\n * CSS variants for the message input container\n * @typedef {Object} MessageInputVariants\n * @property {string} default - Default styling\n * @property {string} solid - Solid styling with shadow effects\n * @property {string} bordered - Bordered styling with border emphasis\n */\nconst messageInputVariants = cva(\"w-full\", {\n  variants: {\n    variant: {\n      default: \"\",\n      solid: [\n        \"[&>div]:bg-background\",\n        \"[&>div]:border-0\",\n        \"[&>div]:shadow-xl [&>div]:shadow-black/5 [&>div]:dark:shadow-black/20\",\n        \"[&>div]:ring-1 [&>div]:ring-black/5 [&>div]:dark:ring-white/10\",\n        \"[&_textarea]:bg-transparent\",\n        \"[&_textarea]:rounded-lg\",\n      ].join(\" \"),\n      bordered: [\n        \"[&>div]:bg-transparent\",\n        \"[&>div]:border-2 [&>div]:border-gray-300 [&>div]:dark:border-zinc-600\",\n        \"[&>div]:shadow-none\",\n        \"[&_textarea]:bg-transparent\",\n        \"[&_textarea]:border-0\",\n      ].join(\" \"),\n    },\n  },\n  defaultVariants: {\n    variant: \"default\",\n  },\n});\n\n/**\n * @typedef MessageInputContextValue\n * @property {string} value - The current input value\n * @property {function} setValue - Function to update the input value\n * @property {function} submit - Function to submit the message\n * @property {function} handleSubmit - Function to handle form submission\n * @property {boolean} isPending - Whether a submission is in progress\n * @property {Error|null} error - Any error from the submission\n * @property {TamboEditor|null} editorRef - Reference to the TamboEditor instance\n * @property {string | null} submitError - Error from the submission\n * @property {function} setSubmitError - Function to set the submission error\n * @property {string | null} imageError - Error related to image uploads\n * @property {function} setImageError - Function to set the image upload error\n * @property {TamboElicitationRequest | null} elicitation - Current elicitation request (read-only)\n * @property {function} resolveElicitation - Function to resolve the elicitation promise (automatically clears state)\n */\ninterface MessageInputContextValue {\n  value: string;\n  setValue: (value: string) => void;\n  submit: (options: {\n    streamResponse?: boolean;\n    resourceNames: Record<string, string>;\n  }) => Promise<void>;\n  handleSubmit: (e: React.FormEvent) => Promise<void>;\n  isPending: boolean;\n  error: Error | null;\n  editorRef: React.RefObject<TamboEditor>;\n  submitError: string | null;\n  setSubmitError: React.Dispatch<React.SetStateAction<string | null>>;\n  imageError: string | null;\n  setImageError: React.Dispatch<React.SetStateAction<string | null>>;\n  elicitation: TamboElicitationRequest | null;\n  resolveElicitation: ((response: TamboElicitationResponse) => void) | null;\n}\n\n/**\n * React Context for sharing message input data and functions among sub-components.\n * @internal\n */\nconst MessageInputContext =\n  React.createContext<MessageInputContextValue | null>(null);\n\n/**\n * Hook to access the message input context.\n * Throws an error if used outside of a MessageInput component.\n * @returns {MessageInputContextValue} The message input context value.\n * @throws {Error} If used outside of MessageInput.\n * @internal\n */\nconst useMessageInputContext = () => {\n  const context = React.useContext(MessageInputContext);\n  if (!context) {\n    throw new Error(\n      \"MessageInput sub-components must be used within a MessageInput\",\n    );\n  }\n  return context;\n};\n\n/**\n * Props for the MessageInput component.\n * Extends standard HTMLFormElement attributes.\n */\nexport interface MessageInputProps extends React.HTMLAttributes<HTMLFo\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/message-suggestions.tsx",
      "path": "src/components/tambo/message-suggestions.tsx",
      "name": "message-suggestions.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { MessageGenerationStage } from \"./message-generation-stage\";\nimport { Tooltip, TooltipProvider } from \"./suggestions-tooltip\";\nimport { cn } from \"@/lib/utils\";\nimport type { Suggestion, TamboThread } from \"@tambo-ai/react\";\nimport {\n  GenerationStage,\n  useTambo,\n  useTamboSuggestions,\n} from \"@tambo-ai/react\";\nimport { Loader2Icon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useEffect, useRef } from \"react\";\n\n/**\n * @typedef MessageSuggestionsContextValue\n * @property {Array} suggestions - Array of suggestion objects\n * @property {string|null} selectedSuggestionId - ID of the currently selected suggestion\n * @property {function} accept - Function to accept a suggestion\n * @property {boolean} isGenerating - Whether suggestions are being generated\n * @property {Error|null} error - Any error from generation\n * @property {object} thread - The current Tambo thread\n */\ninterface MessageSuggestionsContextValue {\n  suggestions: Suggestion[];\n  selectedSuggestionId: string | null;\n  accept: (options: { suggestion: Suggestion }) => Promise<void>;\n  isGenerating: boolean;\n  error: Error | null;\n  thread: TamboThread;\n  isMac: boolean;\n}\n\n/**\n * React Context for sharing suggestion data and functions among sub-components.\n * @internal\n */\nconst MessageSuggestionsContext =\n  React.createContext<MessageSuggestionsContextValue | null>(null);\n\n/**\n * Hook to access the message suggestions context.\n * @returns {MessageSuggestionsContextValue} The message suggestions context value.\n * @throws {Error} If used outside of MessageSuggestions.\n * @internal\n */\nconst useMessageSuggestionsContext = () => {\n  const context = React.useContext(MessageSuggestionsContext);\n  if (!context) {\n    throw new Error(\n      \"MessageSuggestions sub-components must be used within a MessageSuggestions\",\n    );\n  }\n  return context;\n};\n\n/**\n * Props for the MessageSuggestions component.\n * Extends standard HTMLDivElement attributes.\n */\nexport interface MessageSuggestionsProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Maximum number of suggestions to display (default: 3) */\n  maxSuggestions?: number;\n  /** The child elements to render within the container. */\n  children?: React.ReactNode;\n  /** Pre-seeded suggestions to display initially */\n  initialSuggestions?: Suggestion[];\n}\n\n/**\n * The root container for message suggestions.\n * It establishes the context for its children and handles overall state management.\n * @component MessageSuggestions\n * @example\n * ```tsx\n * <MessageSuggestions maxSuggestions={3}>\n *   <MessageSuggestions.Status />\n *   <MessageSuggestions.List />\n * </MessageSuggestions>\n * ```\n */\nconst MessageSuggestions = React.forwardRef<\n  HTMLDivElement,\n  MessageSuggestionsProps\n>(\n  (\n    {\n      children,\n      className,\n      maxSuggestions = 3,\n      initialSuggestions = [],\n      ...props\n    },\n    ref,\n  ) => {\n    const { thread } = useTambo();\n    const {\n      suggestions: generatedSuggestions,\n      selectedSuggestionId,\n      accept,\n      generateResult: { isPending: isGenerating, error },\n    } = useTamboSuggestions({ maxSuggestions });\n\n    // Combine initial and generated suggestions, but only use initial ones when thread is empty\n    const suggestions = React.useMemo(() => {\n      // Only use pre-seeded suggestions if thread is empty\n      if (!thread?.messages?.length && initialSuggestions.length > 0) {\n        return initialSuggestions.slice(0, maxSuggestions);\n      }\n      // Otherwise use generated suggestions\n      return generatedSuggestions;\n    }, [\n      thread?.messages?.length,\n      generatedSuggestions,\n      initialSuggestions,\n      maxSuggestions,\n    ]);\n\n    const isMac =\n      typeof navigator !== \"undefined\" && navigator.platform.startsWith(\"Mac\");\n\n    // Track the last AI message ID to detect new messages\n    const lastAiMessageIdRef = useRef<string | null>(null);\n    const loadingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n    const contextValue = React.useMemo(\n      () => ({\n        suggestions,\n        selectedSuggestionId,\n        accept,\n        isGenerating,\n        error,\n        thread,\n        isMac,\n      }),\n      [\n        suggestions,\n        selectedSuggestionId,\n        accept,\n        isGenerating,\n        error,\n        thread,\n        isMac,\n      ],\n    );\n\n    // Find the last AI message\n    const lastAiMessage = thread?.messages\n      ? [...thread.messages].reverse().find((msg) => msg.role === \"assistant\")\n      : null;\n\n    // When a new AI message appears, update the reference\n    useEffect(() => {\n      if (lastAiMessage && lastAiMessage.id !== lastAiMessageIdRef.current) {\n        lastAiMessageIdRef.current = lastAiMessage.id;\n\n        if (loadingTimeoutRef.current) {\n          clearTimeout(loadingTimeoutRef.current);\n        }\n\n        loadingTimeoutRef.current = setTimeout(() => {}, 5000);\n      }\n\n      return () => {\n        if (loadingTimeoutRef.current) {\n          clearTimeout(loadingTimeoutRef.current);\n        }\n      };\n    }, [lastAiMessage, suggestions.length]);\n\n    // Handle keyboard shortcuts for selecting suggestions\n    useEffect(() => {\n      if (!suggestions || suggestions.length === 0) return;\n\n      const handleKeyDown = (event: KeyboardEvent) => {\n        const modifierPressed = isMac\n          ? event.metaKey && event.altKey\n          : event.ctrlKey && event.altKey;\n\n        if (modifierPressed) {\n          const keyNum = parseInt(event.key);\n          if (!isNaN(keyNum) && keyNum > 0 && keyNum <= suggestions.length) {\n            event.preventDefault();\n            const suggestionIndex = keyNum - 1;\n            void accept({ suggestion: suggestions[suggestionIndex] });\n          }\n        }\n      };\n\n      document.addEventListener(\"keydown\", handleKeyDown);\n\n      return () => {\n        document.removeEventListener(\"keydown\", handleKeyDown);\n      };\n    }, [suggestions, accept, isMac]);\n\n    // If we have no messages yet and no initial suggestions, render nothing\n    if (!thread?.messages?.length && initialSuggestions.length === 0) {\n      return null;\n    }\n\n    return (\n      <MessageSuggestionsContext.Provider value={contextValue}>\n        <TooltipProvider>\n          <div\n            ref={ref}\n            className={cn(\"px-4 pb-2\", className)}\n            data-slot=\"message-suggestions-container\"\n            {...props}\n          >\n            {children}\n          </div>\n        </TooltipProvider>\n      </MessageSuggestionsContext.Provider>\n    );\n  },\n);\nMessageSuggestions.displayName = \"MessageSuggestions\";\n\n/**\n * Props for the MessageSuggestionsStatus component.\n * Extends standard HTMLDivElement attributes.\n */\nexport type MessageSuggestionsStatusProps =\n  React.HTMLAttributes<HTMLDivElement>;\n\n/**\n * Displays loading, error, or generation stage information.\n * Automatically connects to the context to show the appropriate status.\n * @component MessageSuggestions.Status\n * @example\n * ```tsx\n * <MessageSuggestions>\n *   <MessageSuggestions.Status />\n *   <MessageSuggestions.List />\n * </MessageSuggestions>\n * ```\n */\nconst MessageSuggestionsStatus = React.forwardRef<\n  HTMLDivElement,\n  MessageSuggestionsStatusProps\n>(({ className, ...props }, ref) => {\n  const { error, isGenerating, thread } = useMessageSuggestionsContext();\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"p-2 rounded-md text-sm bg-transparent\",\n        !error &&\n          !isGenerating &&\n          (!thread?.generationStage ||\n            thread.generationStage === GenerationStage.COMPLETE)\n          ? \"p-0 min-h-0 mb-0\"\n          : \"\",\n        className,\n      )}\n      data-slot=\"message-suggestions-status\"\n      {...props}\n    >\n      {/* Error state */}\n      {error && (\n        <div className=\"p-2 rounded-md text-sm bg-red-50 text-red-500\">\n          <p>{error.message}</p>\n        </div>\n      )}\n\n      {/* Always render a container for generation stage to prevent layout shifts */}\n      <div className=\"generation-stage-container\">\n        <GenerationStageContent\n          generationStage={thread?.generationStage}\n          isGenerating={isGenerating}\n        />\n      </div>\n    </div>\n  );\n});\nMessageSuggestionsStatus.displayName = \"MessageSuggestions.Status\";\n\n/**\n * Internal component to render generation stage content\n */\nfunction GenerationStageContent({\n  generationStage,\n  isGenerating,\n}: {\n  generationStage?: string;\n  isGenerating: boolean;\n}) {\n  if (generationStage && generationStage !== GenerationStage.COMPLETE) {\n    return <MessageGenerationStage />;\n  }\n  if (isGenerating) {\n    return (\n      <div className=\"flex items-center gap-2 text-muted-foreground\">\n        <Loader2Icon className=\"h-4 w-4 animate-spin\" />\n        <p>Generating suggestions...</p>\n      </div>\n    );\n  }\n  return null;\n}\n\n/**\n * Props for the MessageSuggestionsList component.\n * Extends standard HTMLDivElement attributes.\n */\nexport type MessageSuggestionsListProps = React.HTMLAttributes<HTMLDivElement>;\n\n/**\n * Displays the list of suggestion buttons.\n * Automatically connects to the context to show the suggestions.\n * @component MessageSuggestions.List\n * @example\n * ```tsx\n * <MessageSuggestions>\n *   <MessageSuggestions.Status />\n *   <MessageSuggestions.List />\n * </MessageSuggestions>\n * ```\n */\nconst MessageSuggestionsList = React.forwardRef<\n  HTMLDivElement,\n  MessageSuggestionsListProps\n>(({ className, ...props }, ref) => {\n  const { suggestions, selectedSuggestionId, accept, isGenerating, isMac } =\n    useMessageSuggestionsContext();\n\n  const modKey = isMac ? \"\" : \"Ctrl\";\n  const altKey = isMac ? \"\" : \"Alt\";\n\n  // Create placeholder suggestions when there are no real suggestions\n  const placeholders = Array(3).fill(null);\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"flex space-x-2 overflow-x-auto pb-2 rounded-md bg-transparent min-h-[2.5rem]\",\n        isGenerating ? \"opacity-70\" : \"\",\n        className,\n      )}\n      data-slot=\"message-suggestions-list\"\n      {...props}\n    >\n      {suggestions.length > 0\n        ? suggestions.map((suggestion, index) => (\n            <Tooltip\n              key={suggestion.id}\n              content={\n                <span suppressHydrationWarning>\n                  {modKey}+{altKey}+{index + 1}\n                </span>\n              }\n              side=\"top\"\n            >\n              <button\n                className={cn(\n                  \"py-2 px-2.5 rounded-2xl text-xs transition-colors\",\n                  \"border border-flat\",\n                  getSuggestionButtonClassName({\n                    isGenerating,\n                    isSelected: selectedSuggestionId === suggestion.id,\n                  }),\n                )}\n                onClick={async () =>\n                  !isGenerating && (await accept({ suggestion }))\n                }\n                disabled={isGenerating}\n                data-suggestion-id={suggestion.id}\n                data-suggestion-index={index}\n              >\n                <span className=\"font-medium\">{suggestion.title}</span>\n              </button>\n            </Tooltip>\n          ))\n        : // Render placeholder buttons when no suggestions are available\n          placeholders.map((_, index) => (\n            <div\n              key={`placeholder-${index}`}\n              className=\"py-2 px-2.5 rounded-2xl text-xs border border-flat bg-muted/20 text-transparent animate-pulse\"\n              data-placeholder-index={index}\n            >\n              <span className=\"invisible\">Placeholder</span>\n            </div>\n          ))}\n    </div>\n  );\n});\nMessageSuggestionsList.displayName = \"MessageSuggestions.List\";\n\n/**\n * Internal function to get className for suggestion button based on state\n */\nfunction getSuggestionButtonClassName({\n  isGenerating,\n  isSelected,\n}: {\n  isGenerating: boolean;\n  isSelected: boolean;\n}) {\n  if (isGenerating) {\n    return \"bg-muted/50 text-muted-foreground\";\n  }\n  if (isSelected) {\n    return \"bg-accent text-accent-foreg\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/message-thread-collapsible.tsx",
      "path": "src/components/tambo/message-thread-collapsible.tsx",
      "name": "message-thread-collapsible.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport type { messageVariants } from \"@/components/tambo/message\";\nimport {\n  MessageInput,\n  MessageInputError,\n  MessageInputFileButton,\n  MessageInputMcpPromptButton,\n  MessageInputMcpResourceButton,\n  MessageInputSubmitButton,\n  MessageInputTextarea,\n  MessageInputToolbar,\n} from \"@/components/tambo/message-input\";\nimport {\n  MessageSuggestions,\n  MessageSuggestionsList,\n  MessageSuggestionsStatus,\n} from \"@/components/tambo/message-suggestions\";\nimport { ScrollableMessageContainer } from \"@/components/tambo/scrollable-message-container\";\nimport {\n  ThreadContent,\n  ThreadContentMessages,\n} from \"@/components/tambo/thread-content\";\nimport { ThreadDropdown } from \"@/components/tambo/thread-dropdown\";\nimport { cn } from \"@/lib/utils\";\nimport { type Suggestion } from \"@tambo-ai/react\";\nimport { type VariantProps } from \"class-variance-authority\";\nimport { XIcon } from \"lucide-react\";\nimport { Collapsible } from \"radix-ui\";\nimport * as React from \"react\";\n\n/**\n * Props for the MessageThreadCollapsible component\n * @interface\n * @extends React.HTMLAttributes<HTMLDivElement>\n */\nexport interface MessageThreadCollapsibleProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Whether the collapsible should be open by default (default: false) */\n  defaultOpen?: boolean;\n  /**\n   * Controls the visual styling of messages in the thread.\n   * Possible values include: \"default\", \"compact\", etc.\n   * These values are defined in messageVariants from \"@/components/tambo/message\".\n   * @example variant=\"compact\"\n   */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n  /** Optional override for height of the thread content. If not provided, defaults to 80vh. Supports any CSS height value (e.g., \"700px\", \"80vh\", \"90%\"). */\n  height?: string;\n  /** @deprecated Use height instead. This prop will be removed in a future version. */\n  maxHeight?: string;\n}\n\n/**\n * A collapsible chat thread component with keyboard shortcuts and thread management\n * @component\n * @example\n * ```tsx\n * <MessageThreadCollapsible\n *   defaultOpen={false}\n *   className=\"left-4\" // Position on the left instead of right\n *   variant=\"default\"\n * />\n * ```\n */\n\n/**\n * Custom hook for managing collapsible state with keyboard shortcuts\n */\nconst useCollapsibleState = (defaultOpen = false) => {\n  const [isOpen, setIsOpen] = React.useState(defaultOpen);\n  const isMac =\n    typeof navigator !== \"undefined\" && navigator.platform.startsWith(\"Mac\");\n  const shortcutText = isMac ? \"K\" : \"Ctrl+K\";\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if ((event.metaKey || event.ctrlKey) && event.key === \"k\") {\n        event.preventDefault();\n        setIsOpen((prev) => !prev);\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, []);\n\n  return { isOpen, setIsOpen, shortcutText };\n};\n\n/**\n * Props for the CollapsibleContainer component\n */\ninterface CollapsibleContainerProps extends React.HTMLAttributes<HTMLDivElement> {\n  isOpen: boolean;\n  onOpenChange: (open: boolean) => void;\n  children: React.ReactNode;\n}\n\n/**\n * Container component for the collapsible panel\n */\nconst CollapsibleContainer = React.forwardRef<\n  HTMLDivElement,\n  CollapsibleContainerProps\n>(({ className, isOpen, onOpenChange, children, ...props }, ref) => (\n  <Collapsible.Root\n    ref={ref}\n    open={isOpen}\n    onOpenChange={onOpenChange}\n    className={cn(\n      \"fixed bottom-4 right-4 w-full max-w-sm sm:max-w-md md:max-w-lg rounded-lg shadow-lg bg-background border border-border\",\n      \"transition-all duration-300 ease-in-out\",\n      className,\n    )}\n    {...props}\n  >\n    {children}\n  </Collapsible.Root>\n));\nCollapsibleContainer.displayName = \"CollapsibleContainer\";\n\n/**\n * Props for the CollapsibleTrigger component\n */\ninterface CollapsibleTriggerProps {\n  isOpen: boolean;\n  shortcutText: string;\n  onClose: () => void;\n  onThreadChange: () => void;\n  config: {\n    labels: {\n      openState: string;\n      closedState: string;\n    };\n  };\n}\n\n/**\n * Trigger component for the collapsible panel\n */\nconst CollapsibleTrigger = ({\n  isOpen,\n  shortcutText,\n  onClose,\n  onThreadChange,\n  config,\n}: CollapsibleTriggerProps) => (\n  <>\n    {!isOpen && (\n      <Collapsible.Trigger asChild>\n        <button\n          className={cn(\n            \"flex items-center justify-between w-full p-4\",\n            \"hover:bg-muted/50 transition-colors\",\n          )}\n          aria-expanded={isOpen}\n          aria-controls=\"message-thread-content\"\n        >\n          <span>{config.labels.closedState}</span>\n          <span\n            className=\"text-xs text-muted-foreground pl-8\"\n            suppressHydrationWarning\n          >\n            {`(${shortcutText})`}\n          </span>\n        </button>\n      </Collapsible.Trigger>\n    )}\n    {isOpen && (\n      <div className=\"flex items-center justify-between w-full p-4\">\n        <div className=\"flex items-center gap-2\">\n          <span>{config.labels.openState}</span>\n          <ThreadDropdown onThreadChange={onThreadChange} />\n        </div>\n        <button\n          className=\"p-1 rounded-full hover:bg-muted/70 transition-colors cursor-pointer\"\n          onClick={(e) => {\n            e.stopPropagation();\n            onClose();\n          }}\n          aria-label=\"Close\"\n        >\n          <XIcon className=\"h-4 w-4\" />\n        </button>\n      </div>\n    )}\n  </>\n);\nCollapsibleTrigger.displayName = \"CollapsibleTrigger\";\n\nexport const MessageThreadCollapsible = React.forwardRef<\n  HTMLDivElement,\n  MessageThreadCollapsibleProps\n>(\n  (\n    { className, defaultOpen = false, variant, height, maxHeight, ...props },\n    ref,\n  ) => {\n    const { isOpen, setIsOpen, shortcutText } =\n      useCollapsibleState(defaultOpen);\n\n    // Backward compatibility: prefer height, fall back to maxHeight\n    const effectiveHeight = height ?? maxHeight;\n\n    const handleThreadChange = React.useCallback(() => {\n      setIsOpen(true);\n    }, [setIsOpen]);\n\n    /**\n     * Configuration for the MessageThreadCollapsible component\n     */\n    const THREAD_CONFIG = {\n      labels: {\n        openState: \"Conversations\",\n        closedState: \"Start chatting with tambo\",\n      },\n    };\n\n    const defaultSuggestions: Suggestion[] = [\n      {\n        id: \"suggestion-1\",\n        title: \"Get started\",\n        detailedSuggestion: \"What can you help me with?\",\n        messageId: \"welcome-query\",\n      },\n      {\n        id: \"suggestion-2\",\n        title: \"Learn more\",\n        detailedSuggestion: \"Tell me about your capabilities.\",\n        messageId: \"capabilities-query\",\n      },\n      {\n        id: \"suggestion-3\",\n        title: \"Examples\",\n        detailedSuggestion: \"Show me some example queries I can try.\",\n        messageId: \"examples-query\",\n      },\n    ];\n\n    return (\n      <CollapsibleContainer\n        ref={ref}\n        isOpen={isOpen}\n        onOpenChange={setIsOpen}\n        className={className}\n        {...props}\n      >\n        <CollapsibleTrigger\n          isOpen={isOpen}\n          shortcutText={shortcutText}\n          onClose={() => setIsOpen(false)}\n          onThreadChange={handleThreadChange}\n          config={THREAD_CONFIG}\n        />\n        <Collapsible.Content>\n          <div\n            className={cn(\"flex flex-col\", effectiveHeight ? \"\" : \"h-[80vh]\")}\n            style={effectiveHeight ? { height: effectiveHeight } : undefined}\n          >\n            {/* Message thread content */}\n            <ScrollableMessageContainer className=\"p-4\">\n              <ThreadContent variant={variant}>\n                <ThreadContentMessages />\n              </ThreadContent>\n            </ScrollableMessageContainer>\n\n            {/* Message Suggestions Status */}\n            <MessageSuggestions>\n              <MessageSuggestionsStatus />\n            </MessageSuggestions>\n\n            {/* Message input */}\n            <div className=\"p-4\">\n              <MessageInput>\n                <MessageInputTextarea placeholder=\"Type your message or paste images...\" />\n                <MessageInputToolbar>\n                  <MessageInputFileButton />\n                  <MessageInputMcpPromptButton />\n                  <MessageInputMcpResourceButton />\n                  {/* Uncomment this to enable client-side MCP config modal button */}\n                  {/* <MessageInputMcpConfigButton /> */}\n                  <MessageInputSubmitButton />\n                </MessageInputToolbar>\n                <MessageInputError />\n              </MessageInput>\n            </div>\n\n            {/* Message suggestions */}\n            <MessageSuggestions initialSuggestions={defaultSuggestions}>\n              <MessageSuggestionsList />\n            </MessageSuggestions>\n          </div>\n        </Collapsible.Content>\n      </CollapsibleContainer>\n    );\n  },\n);\nMessageThreadCollapsible.displayName = \"MessageThreadCollapsible\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/message-thread-full.tsx",
      "path": "src/components/tambo/message-thread-full.tsx",
      "name": "message-thread-full.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport type { messageVariants } from \"@/components/tambo/message\";\nimport {\n  MessageInput,\n  MessageInputError,\n  MessageInputFileButton,\n  MessageInputMcpPromptButton,\n  MessageInputMcpResourceButton,\n  MessageInputSubmitButton,\n  MessageInputTextarea,\n  MessageInputToolbar,\n} from \"@/components/tambo/message-input\";\nimport {\n  MessageSuggestions,\n  MessageSuggestionsList,\n  MessageSuggestionsStatus,\n} from \"@/components/tambo/message-suggestions\";\nimport { ScrollableMessageContainer } from \"@/components/tambo/scrollable-message-container\";\nimport { ThreadContainer, useThreadContainerContext } from \"./thread-container\";\nimport {\n  ThreadContent,\n  ThreadContentMessages,\n} from \"@/components/tambo/thread-content\";\nimport {\n  ThreadHistory,\n  ThreadHistoryHeader,\n  ThreadHistoryList,\n  ThreadHistoryNewButton,\n  ThreadHistorySearch,\n} from \"@/components/tambo/thread-history\";\nimport { useMergeRefs } from \"@/lib/thread-hooks\";\nimport type { Suggestion } from \"@tambo-ai/react\";\nimport type { VariantProps } from \"class-variance-authority\";\nimport * as React from \"react\";\n\n/**\n * Props for the MessageThreadFull component\n */\nexport interface MessageThreadFullProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * Controls the visual styling of messages in the thread.\n   * Possible values include: \"default\", \"compact\", etc.\n   * These values are defined in messageVariants from \"@/components/tambo/message\".\n   * @example variant=\"compact\"\n   */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n}\n\n/**\n * A full-screen chat thread component with message history, input, and suggestions\n */\nexport const MessageThreadFull = React.forwardRef<\n  HTMLDivElement,\n  MessageThreadFullProps\n>(({ className, variant, ...props }, ref) => {\n  const { containerRef, historyPosition } = useThreadContainerContext();\n  const mergedRef = useMergeRefs<HTMLDivElement | null>(ref, containerRef);\n\n  const threadHistorySidebar = (\n    <ThreadHistory position={historyPosition}>\n      <ThreadHistoryHeader />\n      <ThreadHistoryNewButton />\n      <ThreadHistorySearch />\n      <ThreadHistoryList />\n    </ThreadHistory>\n  );\n\n  const defaultSuggestions: Suggestion[] = [\n    {\n      id: \"suggestion-1\",\n      title: \"Get started\",\n      detailedSuggestion: \"What can you help me with?\",\n      messageId: \"welcome-query\",\n    },\n    {\n      id: \"suggestion-2\",\n      title: \"Learn more\",\n      detailedSuggestion: \"Tell me about your capabilities.\",\n      messageId: \"capabilities-query\",\n    },\n    {\n      id: \"suggestion-3\",\n      title: \"Examples\",\n      detailedSuggestion: \"Show me some example queries I can try.\",\n      messageId: \"examples-query\",\n    },\n  ];\n\n  return (\n    <div className=\"flex h-full w-full\">\n      {/* Thread History Sidebar - rendered first if history is on the left */}\n      {historyPosition === \"left\" && threadHistorySidebar}\n\n      <ThreadContainer\n        ref={mergedRef}\n        disableSidebarSpacing\n        className={className}\n        {...props}\n      >\n        <ScrollableMessageContainer className=\"p-4\">\n          <ThreadContent variant={variant}>\n            <ThreadContentMessages />\n          </ThreadContent>\n        </ScrollableMessageContainer>\n\n        {/* Message suggestions status */}\n        <MessageSuggestions>\n          <MessageSuggestionsStatus />\n        </MessageSuggestions>\n\n        {/* Message input */}\n        <div className=\"px-4 pb-4\">\n          <MessageInput>\n            <MessageInputTextarea placeholder=\"Type your message or paste images...\" />\n            <MessageInputToolbar>\n              <MessageInputFileButton />\n              <MessageInputMcpPromptButton />\n              <MessageInputMcpResourceButton />\n              {/* Uncomment this to enable client-side MCP config modal button */}\n              {/* <MessageInputMcpConfigButton /> */}\n              <MessageInputSubmitButton />\n            </MessageInputToolbar>\n            <MessageInputError />\n          </MessageInput>\n        </div>\n\n        {/* Message suggestions */}\n        <MessageSuggestions initialSuggestions={defaultSuggestions}>\n          <MessageSuggestionsList />\n        </MessageSuggestions>\n      </ThreadContainer>\n\n      {/* Thread History Sidebar - rendered last if history is on the right */}\n      {historyPosition === \"right\" && threadHistorySidebar}\n    </div>\n  );\n});\nMessageThreadFull.displayName = \"MessageThreadFull\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/message-thread-panel.tsx",
      "path": "src/components/tambo/message-thread-panel.tsx",
      "name": "message-thread-panel.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport {\n  MessageInput,\n  MessageInputTextarea,\n  MessageInputToolbar,\n  MessageInputSubmitButton,\n  MessageInputError,\n  MessageInputFileButton,\n  MessageInputMcpPromptButton,\n  MessageInputMcpResourceButton,\n  // MessageInputMcpConfigButton,\n} from \"@/components/tambo/message-input\";\nimport {\n  MessageSuggestions,\n  MessageSuggestionsStatus,\n  MessageSuggestionsList,\n} from \"@/components/tambo/message-suggestions\";\nimport {\n  ThreadHistory,\n  ThreadHistoryHeader,\n  ThreadHistoryNewButton,\n  ThreadHistorySearch,\n  ThreadHistoryList,\n} from \"@/components/tambo/thread-history\";\nimport {\n  ThreadContent,\n  ThreadContentMessages,\n} from \"@/components/tambo/thread-content\";\nimport type { messageVariants } from \"@/components/tambo/message\";\nimport { ScrollableMessageContainer } from \"@/components/tambo/scrollable-message-container\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  useMergeRefs,\n  useCanvasDetection,\n  usePositioning,\n} from \"@/lib/thread-hooks\";\nimport type { VariantProps } from \"class-variance-authority\";\nimport * as React from \"react\";\nimport { useRef } from \"react\";\nimport type { Suggestion } from \"@tambo-ai/react\";\n\n/**\n * Props for the MessageThreadPanel component\n * @interface\n */\nexport interface MessageThreadPanelProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * Controls the visual styling of messages in the thread.\n   * Possible values include: \"default\", \"compact\", etc.\n   * These values are defined in messageVariants from \"@/components/tambo/message\".\n   * @example variant=\"compact\"\n   */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n}\n\n/**\n * Props for the ResizablePanel component\n */\ninterface ResizablePanelProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Children elements to render inside the container */\n  children: React.ReactNode;\n  /** Whether the panel should be positioned on the left (true) or right (false) */\n  isLeftPanel: boolean;\n}\n\n/**\n * A resizable panel component with a draggable divider\n */\nconst ResizablePanel = React.forwardRef<HTMLDivElement, ResizablePanelProps>(\n  ({ className, children, isLeftPanel, ...props }, ref) => {\n    const [width, setWidth] = React.useState(956);\n    const isResizing = React.useRef(false);\n    const lastUpdateRef = React.useRef(0);\n\n    const handleMouseMove = React.useCallback(\n      (e: MouseEvent) => {\n        if (!isResizing.current) return;\n\n        const now = Date.now();\n        if (now - lastUpdateRef.current < 16) return;\n        lastUpdateRef.current = now;\n\n        const windowWidth = window.innerWidth;\n\n        requestAnimationFrame(() => {\n          let newWidth;\n          if (isLeftPanel) {\n            newWidth = Math.round(e.clientX);\n          } else {\n            newWidth = Math.round(windowWidth - e.clientX);\n          }\n\n          // Ensure minimum width of 300px\n          const clampedWidth = Math.max(\n            300,\n            Math.min(windowWidth - 300, newWidth),\n          );\n          setWidth(clampedWidth);\n\n          // Update both panel and canvas widths using the same divider position\n          if (isLeftPanel) {\n            document.documentElement.style.setProperty(\n              \"--panel-left-width\",\n              `${clampedWidth}px`,\n            );\n          } else {\n            document.documentElement.style.setProperty(\n              \"--panel-right-width\",\n              `${clampedWidth}px`,\n            );\n          }\n        });\n      },\n      [isLeftPanel],\n    );\n\n    return (\n      <div\n        ref={ref}\n        className={cn(\n          \"h-screen flex flex-col bg-background relative\",\n          \"transition-[width] duration-75 ease-out\",\n          \"overflow-x-auto\",\n          isLeftPanel\n            ? \"border-r border-border\"\n            : \"border-l border-border ml-auto\",\n          className,\n        )}\n        style={{\n          width: `${width}px`,\n          flex: \"0 0 auto\",\n        }}\n        {...props}\n      >\n        {/* Always show resize handle */}\n        <div\n          className={cn(\n            \"absolute top-0 bottom-0 w-1 cursor-ew-resize bg-border hover:bg-accent transition-colors z-50\",\n            isLeftPanel ? \"right-0\" : \"left-0\",\n          )}\n          onMouseDown={(e) => {\n            e.preventDefault();\n            isResizing.current = true;\n            document.body.style.cursor = \"ew-resize\";\n            document.body.style.userSelect = \"none\";\n            document.addEventListener(\"mousemove\", handleMouseMove);\n            document.addEventListener(\n              \"mouseup\",\n              () => {\n                isResizing.current = false;\n                document.body.style.cursor = \"\";\n                document.body.style.userSelect = \"\";\n                document.removeEventListener(\"mousemove\", handleMouseMove);\n              },\n              { once: true },\n            );\n          }}\n        />\n        {children}\n      </div>\n    );\n  },\n);\nResizablePanel.displayName = \"ResizablePanel\";\n\n/**\n * A resizable panel component that displays a chat thread with message history, input, and suggestions\n * @component\n * @example\n * ```tsx\n * // Default left positioning\n * <MessageThreadPanel />\n *\n * // Explicit right positioning\n * <MessageThreadPanel className=\"right\" />\n * ```\n */\nexport const MessageThreadPanel = React.forwardRef<\n  HTMLDivElement,\n  MessageThreadPanelProps\n>(({ className, variant, ...props }, ref) => {\n  const panelRef = useRef<HTMLDivElement>(null);\n  const { hasCanvasSpace, canvasIsOnLeft } = useCanvasDetection(panelRef);\n  const { isLeftPanel, historyPosition } = usePositioning(\n    className,\n    canvasIsOnLeft,\n    hasCanvasSpace,\n  );\n  const mergedRef = useMergeRefs<HTMLDivElement | null>(ref, panelRef);\n\n  const defaultSuggestions: Suggestion[] = [\n    {\n      id: \"suggestion-1\",\n      title: \"Get started\",\n      detailedSuggestion: \"What can you help me with?\",\n      messageId: \"welcome-query\",\n    },\n    {\n      id: \"suggestion-2\",\n      title: \"Learn more\",\n      detailedSuggestion: \"Tell me about your capabilities.\",\n      messageId: \"capabilities-query\",\n    },\n    {\n      id: \"suggestion-3\",\n      title: \"Examples\",\n      detailedSuggestion: \"Show me some example queries I can try.\",\n      messageId: \"examples-query\",\n    },\n  ];\n\n  return (\n    <ResizablePanel\n      ref={mergedRef}\n      isLeftPanel={isLeftPanel}\n      className={className}\n      {...props}\n    >\n      <div className=\"flex h-full relative\">\n        {historyPosition === \"left\" && (\n          <div\n            className=\"flex-none transition-all duration-300 ease-in-out\"\n            style={{ width: \"var(--sidebar-width, 16rem)\" }}\n          >\n            <ThreadHistory\n              defaultCollapsed={true}\n              position=\"left\"\n              className=\"h-full border-0 border-r border-flat\"\n            >\n              <ThreadHistoryHeader />\n              <ThreadHistoryNewButton />\n              <ThreadHistorySearch />\n              <ThreadHistoryList />\n            </ThreadHistory>\n          </div>\n        )}\n\n        <div className=\"flex flex-col h-full flex-grow transition-all duration-300 ease-in-out\">\n          {/* Message thread content */}\n          <ScrollableMessageContainer className=\"p-4\">\n            <ThreadContent variant={variant}>\n              <ThreadContentMessages />\n            </ThreadContent>\n          </ScrollableMessageContainer>\n\n          {/* Message Suggestions Status */}\n          <MessageSuggestions>\n            <MessageSuggestionsStatus />\n          </MessageSuggestions>\n\n          {/* Message input */}\n          <div className=\"p-4\">\n            <MessageInput>\n              <MessageInputTextarea placeholder=\"Type your message or paste images...\" />\n              <MessageInputToolbar>\n                <MessageInputFileButton />\n                <MessageInputMcpPromptButton />\n                <MessageInputMcpResourceButton />\n                {/* Uncomment this to enable client-side MCP config modal button */}\n                {/* <MessageInputMcpConfigButton /> */}\n                <MessageInputSubmitButton />\n              </MessageInputToolbar>\n              <MessageInputError />\n            </MessageInput>\n          </div>\n\n          {/* Message suggestions */}\n          <MessageSuggestions initialSuggestions={defaultSuggestions}>\n            <MessageSuggestionsList />\n          </MessageSuggestions>\n        </div>\n\n        {historyPosition === \"right\" && (\n          <div\n            className=\"flex-none transition-all duration-300 ease-in-out\"\n            style={{ width: \"var(--sidebar-width, 16rem)\" }}\n          >\n            <ThreadHistory\n              defaultCollapsed={true}\n              position=\"right\"\n              className=\"h-full border-0 border-l border-flat\"\n            >\n              <ThreadHistoryHeader />\n              <ThreadHistoryNewButton />\n              <ThreadHistorySearch />\n              <ThreadHistoryList />\n            </ThreadHistory>\n          </div>\n        )}\n      </div>\n    </ResizablePanel>\n  );\n});\nMessageThreadPanel.displayName = \"MessageThreadPanel\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/message.tsx",
      "path": "src/components/tambo/message.tsx",
      "name": "message.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { TamboThreadMessage, useTambo } from \"@tambo-ai/react\";\nimport { cn } from \"@/lib/utils\";\nimport { cva, type VariantProps } from \"class-variance-authority\";\nimport { Check, ChevronDown, ExternalLink, Loader2, X } from \"lucide-react\";\nimport * as React from \"react\";\nimport { Streamdown } from \"streamdown\";\nimport {\n  Message as MessageBase,\n  MessageContentProps as MessageBaseContentProps,\n  MessageContentRenderProps as MessageBaseContentRenderProps,\n  MessageImagesProps as MessageBaseImagesProps,\n  MessageRenderedComponentProps as MessageBaseRenderedComponentProps,\n} from \"@/components/tambo/base/message\";\nimport { MessageLoadingIndicatorProps } from \"@/components/tambo/base/message/loading-indicator/message-loading-indicator\";\nimport { MessageRootProps } from \"@/components/tambo/base/message/root/message-root\";\nimport { useMessageRootContext } from \"@/components/tambo/base/message/root/message-root-context\";\nimport {\n  ReasoningInfo as ReasoningInfoBase,\n  ReasoningInfoRootProps,\n} from \"@/components/tambo/base/reasoning-info\";\nimport {\n  ToolcallInfo as ToolcallInfoBase,\n  type ToolcallInfoRootProps as ToolcallInfoBaseRootProps,\n} from \"@/components/tambo/base/toolcall-info\";\nimport { getSafeContent } from \"../../lib/thread-hooks\";\nimport {\n  createMarkdownComponents,\n  markdownComponents,\n} from \"./markdown-components\";\n\n/**\n * CSS variants for the message container\n * @typedef {Object} MessageVariants\n * @property {string} default - Default styling\n * @property {string} solid - Solid styling with shadow effects\n */\nconst messageVariants = cva(\"flex\", {\n  variants: {\n    variant: {\n      default: \"\",\n      solid: [\n        \"[&>div>div:first-child]:shadow-md\",\n        \"[&>div>div:first-child]:bg-container/50\",\n        \"[&>div>div:first-child]:hover:bg-container\",\n        \"[&>div>div:first-child]:transition-all\",\n        \"[&>div>div:first-child]:duration-200\",\n      ].join(\" \"),\n    },\n  },\n  defaultVariants: {\n    variant: \"default\",\n  },\n});\n\n/**\n * Props for the Message component.\n */\nexport interface MessageProps extends MessageRootProps {\n  /** Optional styling variant for the message container. */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n}\n\n/**\n * The root container for a message component.\n * It establishes the context for its children and applies alignment styles based on the role.\n * @component Message\n * @example\n * ```tsx\n * <Message role=\"user\" message={messageData} variant=\"solid\">\n *   <Message.Bubble />\n *   <Message.RenderedComponentArea />\n * </Message>\n * ```\n */\nconst Message = React.forwardRef<HTMLDivElement, MessageProps>(\n  ({ className, variant, message, children, role, ...props }, ref) => {\n    return (\n      <MessageBase.Root\n        ref={ref}\n        className={cn(\n          messageVariants({ variant }),\n          \"data-[message-role=assistant]:w-full\",\n          className,\n        )}\n        message={message}\n        role={role}\n        {...props}\n      >\n        {children}\n      </MessageBase.Root>\n    );\n  },\n);\nMessage.displayName = \"Message\";\n\n/**\n * Loading indicator with bouncing dots animation.\n *\n * A reusable component that displays three animated dots for loading states.\n * Used in message content and tool status areas.\n *\n * @component\n * @param props - Standard HTML div props\n * @param props.className - Optional CSS classes to apply\n * @returns Animated loading indicator component\n */\nconst LoadingIndicator: React.FC<MessageLoadingIndicatorProps> = ({\n  className,\n  ...props\n}) => {\n  return (\n    <MessageBase.LoadingIndicator\n      className={cn(\n        [\n          \"flex items-center gap-1\",\n          \"*:data-dot:h-1 *:data-dot:w-1 *:data-dot:bg-current *:data-dot:rounded-full *:data-dot:animate-bounce\",\n          \"*:data-[dot=1]:[animation-delay:-0.3s]\",\n          \"*:data-[dot=2]:[animation-delay:-0.2s]\",\n          \"*:data-[dot=3]:[animation-delay:-0.1s]\",\n        ],\n        className,\n      )}\n      {...props}\n    />\n  );\n};\nLoadingIndicator.displayName = \"LoadingIndicator\";\n\n/**\n * Internal component to render message content based on its type\n */\nfunction MessageContentRenderer({\n  contentToRender,\n  markdownContent,\n  markdown,\n}: {\n  contentToRender: unknown;\n  markdownContent: string;\n  markdown: boolean;\n}) {\n  if (!contentToRender) {\n    return <span className=\"text-muted-foreground italic\">Empty message</span>;\n  }\n  if (React.isValidElement(contentToRender)) {\n    return contentToRender;\n  }\n  if (markdown) {\n    return (\n      <Streamdown components={markdownComponents}>{markdownContent}</Streamdown>\n    );\n  }\n  return markdownContent;\n}\n\n/**\n * Props for the MessageImages component.\n */\nexport type MessageImagesProps = Omit<\n  MessageBaseImagesProps,\n  \"renderImage\" | \"children\"\n>;\n\n/**\n * Displays images from message content horizontally.\n * @component MessageImages\n */\nconst MessageImages = React.forwardRef<HTMLDivElement, MessageImagesProps>(\n  ({ className, ...props }, ref) => {\n    return (\n      <MessageBase.Images\n        ref={ref}\n        className={cn(\"flex flex-wrap gap-2 mb-2\", className)}\n        renderImage={({ url, index }) => (\n          <div\n            key={index}\n            className=\"w-32 h-32 rounded-md overflow-hidden shadow-sm hover:shadow-md transition-shadow duration-200\"\n          >\n            <img\n              src={url}\n              alt={`Image ${index + 1}`}\n              width={128}\n              height={128}\n              loading=\"lazy\"\n              decoding=\"async\"\n              className=\"w-full h-full object-cover\"\n            />\n          </div>\n        )}\n        {...props}\n      />\n    );\n  },\n);\nMessageImages.displayName = \"MessageImages\";\n\n/**\n * Props for the MessageContent component.\n */\nexport type MessageContentProps = Omit<MessageBaseContentProps, \"children\">;\n\n/**\n * Displays the message content with optional markdown formatting.\n * Only shows text content - tool calls are handled by ToolcallInfo component.\n * @component MessageContent\n */\nconst MessageContent = React.forwardRef<HTMLDivElement, MessageContentProps>(\n  ({ className, content, markdown = true, ...props }, ref) => {\n    return (\n      <MessageBase.Content\n        ref={ref}\n        className={cn(\n          \"relative block rounded-3xl px-4 py-2 text-[15px] leading-relaxed transition-all duration-200 font-medium max-w-full [&_p]:py-1 [&_li]:list-item\",\n          className,\n        )}\n        content={content}\n        markdown={markdown}\n        render={({\n          content: contentToRender,\n          markdownContent,\n          markdown,\n          isLoading,\n          isCancelled,\n          isReasoning,\n        }: MessageBaseContentRenderProps) => {\n          if (isLoading && !isReasoning) {\n            return (\n              <div\n                className=\"flex items-center justify-start h-4 py-1\"\n                data-slot=\"message-loading-indicator\"\n              >\n                <LoadingIndicator />\n              </div>\n            );\n          }\n\n          return (\n            <div\n              className={cn(\n                \"wrap-break-word\",\n                !markdown && \"whitespace-pre-wrap\",\n              )}\n              data-slot=\"message-content-text\"\n            >\n              <MessageContentRenderer\n                contentToRender={contentToRender}\n                markdownContent={markdownContent}\n                markdown={markdown}\n              />\n              {isCancelled && (\n                <span className=\"text-muted-foreground text-xs\">cancelled</span>\n              )}\n            </div>\n          );\n        }}\n        {...props}\n      />\n    );\n  },\n);\nMessageContent.displayName = \"MessageContent\";\n\n/**\n * Props for the ToolcallInfo component.\n */\nexport interface ToolcallInfoProps extends Omit<\n  ToolcallInfoBaseRootProps,\n  \"children\" | \"message\"\n> {\n  /** Optional flag to render response content as Markdown. Default is true. */\n  markdown?: boolean;\n}\n\nconst toolStatusIconClassName = cva(\"h-3 w-3 text-bold\", {\n  variants: {\n    status: {\n      error: \"text-red-500\",\n      loading: \"text-muted-foreground animate-spin\",\n      success: \"text-green-500\",\n    },\n  },\n  defaultVariants: {\n    status: \"success\",\n  },\n});\n\nfunction ToolcallStatusIcon() {\n  return (\n    <ToolcallInfoBase.StatusIcon\n      render={({ status }) => {\n        let Icon = Check;\n        if (status === \"error\") Icon = X;\n        if (status === \"loading\") Icon = Loader2;\n        return <Icon className={toolStatusIconClassName({ status })} />;\n      }}\n    />\n  );\n}\n\nfunction ToolResultDisplay({\n  content,\n  hasResult,\n  enableMarkdown,\n}: {\n  content: TamboThreadMessage[\"content\"] | null;\n  hasResult: boolean;\n  enableMarkdown: boolean;\n}) {\n  if (!hasResult) {\n    return <span className=\"text-muted-foreground italic\">Empty response</span>;\n  }\n  if (!content) {\n    return null;\n  }\n  return (\n    <ToolResultContent content={content} enableMarkdown={enableMarkdown} />\n  );\n}\n\nfunction ToolcallInfoContent({\n  markdown,\n  message,\n}: {\n  markdown: boolean;\n  message: TamboThreadMessage;\n}) {\n  return (\n    <ToolcallInfoBase.Content\n      forceMount\n      className={cn(\n        \"flex flex-col gap-1 p-3 pl-7 overflow-auto transition-[max-height,opacity,padding] duration-300 w-full truncate\",\n        \"data-[state=open]:max-h-auto data-[state=open]:opacity-100\",\n        \"data-[state=closed]:max-h-0 data-[state=closed]:opacity-0 data-[state=closed]:p-0\",\n      )}\n    >\n      <ToolcallInfoBase.ToolName\n        className=\"whitespace-pre-wrap pl-2\"\n        render={({ toolName }) => `tool: ${toolName}`}\n      />\n      <ToolcallInfoBase.Parameters\n        className=\"whitespace-pre-wrap pl-2\"\n        render={({ parametersString }) => `parameters:\\n${parametersString}`}\n      />\n      <SamplingSubThread parentMessageId={message.id} />\n      <ToolcallInfoBase.Result className=\"pl-2\">\n        {({ content, hasResult }) => (\n          <>\n            <span className=\"whitespace-pre-wrap\">result:</span>\n            <div>\n              <ToolResultDisplay\n                content={content}\n                hasResult={hasResult}\n                enableMarkdown={markdown}\n              />\n            </div>\n          </>\n        )}\n      </ToolcallInfoBase.Result>\n    </ToolcallInfoBase.Content>\n  );\n}\n\ntype ToolcallInfoTriggerProps = React.ComponentProps<\n  typeof ToolcallInfoBase.Trigger\n>;\nconst ToolcallInfoTrigger = React.forwardRef<\n  HTMLButtonElement,\n  ToolcallInfoTriggerProps\n>(function ToolcallInfoTrigger({ children, className, ...props }, ref) {\n  return (\n    <ToolcallInfoBase.Trigger\n      ref={ref}\n      className={cn(\n        \"group/trigger flex items-center gap-1 cursor-pointer hover:bg-muted rounded-md p-1 select-none w-fit\",\n        className,\n      )}\n      {...props}\n    >\n      {children}\n    </ToolcallInfoBase.Trigger>\n  );\n});\nToolcallInfoTrigger.displayName = \"ToolcallInfoTrigger\";\n\n/**\n * Displays tool call information in a collapsible dropdown.\n * Shows tool name, parameters, and associated tool response.\n * @component ToolcallInfo\n */\nconst ToolcallInfo = React.forwardRef<HTMLDivElement, ToolcallInfoProps>(\n  ({ className, markdown = true, ...props }, ref) => {\n    const { message } = useMessageRootContext();\n    return (\n      <ToolcallInfoBase.Root\n        ref={ref}\n        message={message}\n        className={cn(\n          \"flex flex-col items-start text-xs opacity-50\",\n          className,\n        )}\n        {...props}\n      >\n        <div className=\"flex flex-col w-full\">\n          <ToolcallInfoTrigger>\n            <ToolcallStatusIcon />\n            <ToolcallInfoBase.StatusText />\n            <ChevronDown className=\"h-3 w-3 transition-transform duration-200 group-data-[state=closed]/trigger:-rotate-90\" />\n          </ToolcallInfoTrigger>\n          <ToolcallInfoContent markdown={markdown} message={message} />\n        </div>\n      </ToolcallInfoBase.Root>\n    );\n  },\n);\nToolcallInfo.displayName = \"ToolcallInfo\";\n/**\n * Displays a message's child messages in a collapsible \n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/scrollable-message-container.tsx",
      "path": "src/components/tambo/scrollable-message-container.tsx",
      "name": "scrollable-message-container.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { GenerationStage, useTambo } from \"@tambo-ai/react\";\nimport { cn } from \"@/lib/utils\";\nimport * as React from \"react\";\nimport { useCallback, useEffect, useRef, useState, useMemo } from \"react\";\n\n/**\n * Props for the ScrollableMessageContainer component\n */\nexport type ScrollableMessageContainerProps =\n  React.HTMLAttributes<HTMLDivElement>;\n\n/**\n * A scrollable container for message content with auto-scroll functionality.\n * Used across message thread components for consistent scrolling behavior.\n *\n * @example\n * ```tsx\n * <ScrollableMessageContainer>\n *   <ThreadContent variant=\"default\">\n *     <ThreadContentMessages />\n *   </ThreadContent>\n * </ScrollableMessageContainer>\n * ```\n */\nexport const ScrollableMessageContainer = React.forwardRef<\n  HTMLDivElement,\n  ScrollableMessageContainerProps\n>(({ className, children, ...props }, ref) => {\n  const scrollContainerRef = useRef<HTMLDivElement>(null);\n  const { thread } = useTambo();\n  const [shouldAutoscroll, setShouldAutoscroll] = useState(true);\n  const lastScrollTopRef = useRef(0);\n\n  // Handle forwarded ref\n  React.useImperativeHandle(ref, () => scrollContainerRef.current!, []);\n\n  // Create a dependency that represents all content that should trigger autoscroll\n  const messagesContent = useMemo(() => {\n    if (!thread.messages) return null;\n\n    return thread.messages.map((message) => ({\n      id: message.id,\n      content: message.content,\n      tool_calls: message.tool_calls,\n      component: message.component,\n      reasoning: message.reasoning,\n      componentState: message.componentState,\n    }));\n  }, [thread.messages]);\n\n  const generationStage = useMemo(\n    () => thread?.generationStage ?? GenerationStage.IDLE,\n    [thread?.generationStage],\n  );\n\n  // Handle scroll events to detect user scrolling\n  const handleScroll = useCallback(() => {\n    if (!scrollContainerRef.current) return;\n\n    const { scrollTop, scrollHeight, clientHeight } =\n      scrollContainerRef.current;\n    const isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 8; // 8px tolerance for rounding\n\n    // If user scrolled up, disable autoscroll\n    if (scrollTop < lastScrollTopRef.current) {\n      setShouldAutoscroll(false);\n    }\n    // If user is at bottom, enable autoscroll\n    else if (isAtBottom) {\n      setShouldAutoscroll(true);\n    }\n\n    lastScrollTopRef.current = scrollTop;\n  }, []);\n\n  // Auto-scroll to bottom when message content changes\n  useEffect(() => {\n    if (scrollContainerRef.current && messagesContent && shouldAutoscroll) {\n      const scroll = () => {\n        if (scrollContainerRef.current) {\n          scrollContainerRef.current.scrollTo({\n            top: scrollContainerRef.current.scrollHeight,\n            behavior: \"smooth\",\n          });\n        }\n      };\n\n      if (generationStage === GenerationStage.STREAMING_RESPONSE) {\n        // During streaming, scroll immediately\n        requestAnimationFrame(scroll);\n      } else {\n        // For other updates, use a short delay to batch rapid changes\n        const timeoutId = setTimeout(scroll, 50);\n        return () => clearTimeout(timeoutId);\n      }\n    }\n  }, [messagesContent, generationStage, shouldAutoscroll]);\n\n  return (\n    <div\n      ref={scrollContainerRef}\n      onScroll={handleScroll}\n      className={cn(\n        \"flex-1 overflow-y-auto\",\n        \"[&::-webkit-scrollbar]:w-[6px]\",\n        \"[&::-webkit-scrollbar-thumb]:bg-muted-foreground/30\",\n        \"[&::-webkit-scrollbar:horizontal]:h-[4px]\",\n        className,\n      )}\n      data-slot=\"scrollable-message-container\"\n      {...props}\n    >\n      {children}\n    </div>\n  );\n});\nScrollableMessageContainer.displayName = \"ScrollableMessageContainer\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/suggestions-tooltip.tsx",
      "path": "src/components/tambo/suggestions-tooltip.tsx",
      "name": "suggestions-tooltip.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport * as React from \"react\";\nimport * as TooltipPrimitive from \"@radix-ui/react-tooltip\";\nimport { cn } from \"@/lib/utils\";\n\n/**\n * Represents a tooltip component\n * @property {string} className - Optional className for custom styling\n * @property {number} sideOffset - Offset for the tooltip side\n */\n\n// Provider component that should wrap any tooltips\nconst TooltipProvider = TooltipPrimitive.Provider;\n\n// Root component for individual tooltips\nconst TooltipRoot = TooltipPrimitive.Root;\n\n// Trigger component that wraps the element that triggers the tooltip\nconst TooltipTrigger = TooltipPrimitive.Trigger;\n\n// Content component for tooltip\nconst TooltipContent = React.forwardRef<\n  React.ElementRef<typeof TooltipPrimitive.Content>,\n  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>\n>(({ className, sideOffset = 4, ...props }, ref) => (\n  <TooltipPrimitive.Content\n    ref={ref}\n    sideOffset={sideOffset}\n    className={cn(\n      \"z-50 overflow-hidden rounded-md border border-border bg-background px-3 py-1.5 text-xs text-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2\",\n      className,\n    )}\n    {...props}\n  />\n));\nTooltipContent.displayName = TooltipPrimitive.Content.displayName;\n\n// Simplified Tooltip component with a unified API\ninterface TooltipProps {\n  content: React.ReactNode;\n  children: React.ReactNode;\n  delayDuration?: number;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  side?: \"top\" | \"right\" | \"bottom\" | \"left\";\n  align?: \"start\" | \"center\" | \"end\";\n  className?: string;\n}\n\nfunction Tooltip({\n  content,\n  children,\n  delayDuration = 300,\n  open,\n  defaultOpen,\n  onOpenChange,\n  side = \"top\",\n  align = \"center\",\n  className,\n}: TooltipProps) {\n  return (\n    <TooltipRoot\n      open={open}\n      defaultOpen={defaultOpen}\n      onOpenChange={onOpenChange}\n      delayDuration={delayDuration}\n    >\n      <TooltipTrigger asChild>{children}</TooltipTrigger>\n      <TooltipContent side={side} align={align} className={className}>\n        {content}\n      </TooltipContent>\n    </TooltipRoot>\n  );\n}\n\nexport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipRoot,\n  TooltipTrigger,\n};\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/text-editor.tsx",
      "path": "src/components/tambo/text-editor.tsx",
      "name": "text-editor.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport * as Popover from \"@radix-ui/react-popover\";\nimport { cn } from \"@/lib/utils\";\nimport Document from \"@tiptap/extension-document\";\nimport HardBreak from \"@tiptap/extension-hard-break\";\nimport Mention from \"@tiptap/extension-mention\";\nimport Paragraph from \"@tiptap/extension-paragraph\";\nimport Placeholder from \"@tiptap/extension-placeholder\";\nimport Text from \"@tiptap/extension-text\";\nimport {\n  EditorContent,\n  Extension,\n  useEditor,\n  type Editor,\n} from \"@tiptap/react\";\nimport type { SuggestionOptions } from \"@tiptap/suggestion\";\nimport Suggestion from \"@tiptap/suggestion\";\nimport { Cuboid, FileText } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useImperativeHandle, useState } from \"react\";\n\n/**\n * Result of extracting images from clipboard data.\n */\nexport interface ImageItems {\n  imageItems: File[];\n  hasText: boolean;\n}\n\n/**\n * Returns images array and hasText bool from clipboard data.\n * @param clipboardData - The clipboard data from a paste event\n * @returns Object containing extracted images array and whether text was present\n */\nexport function getImageItems(\n  clipboardData: DataTransfer | null | undefined,\n): ImageItems {\n  const items = Array.from(clipboardData?.items ?? []);\n  const imageItems: File[] = [];\n\n  for (const item of items) {\n    if (!item.type.startsWith(\"image/\")) {\n      continue;\n    }\n\n    const image = item.getAsFile();\n    if (image) {\n      imageItems.push(image);\n    }\n  }\n\n  const text = clipboardData?.getData(\"text/plain\") ?? \"\";\n\n  return {\n    imageItems,\n    hasText: text.length > 0 ? true : false,\n  };\n}\n\n/**\n * Minimal editor interface exposed to parent components.\n * Hides TipTap implementation details and exposes only necessary operations.\n */\nexport interface TamboEditor {\n  /** Focus the editor at a specific position */\n  focus(position?: \"start\" | \"end\"): void;\n  /** Set the editor content */\n  setContent(content: string): void;\n  /** Append text to the end of the editor content */\n  appendText(text: string): void;\n  /** Get the text and resource names */\n  getTextWithResourceURIs(): {\n    text: string;\n    resourceNames: Record<string, string>;\n  };\n  /** Check if a mention with the given id exists */\n  hasMention(id: string): boolean;\n  /** Insert a mention node with a following space */\n  insertMention(id: string, label: string): void;\n  /** Set whether the editor is editable */\n  setEditable(editable: boolean): void;\n}\n\n/**\n * Base interface for suggestion items (resources and prompts).\n */\ninterface SuggestionItem {\n  id: string;\n  name: string;\n  icon?: React.ReactNode;\n}\n\n/**\n * Represents a resource item that appears in the \"@\" mention dropdown.\n * Resources are referenced by ID/URI and appear as visual mention nodes in the editor.\n */\nexport interface ResourceItem extends SuggestionItem {\n  componentData?: unknown;\n}\n\n/**\n * Represents a prompt item that appears in the \"/\" command dropdown.\n * Prompts contain text that gets inserted into the editor.\n */\nexport interface PromptItem extends SuggestionItem {\n  /** The actual prompt text to insert into the editor */\n  text: string;\n}\n\nexport interface TextEditorProps {\n  value: string;\n  onChange: (text: string) => void;\n  onResourceNamesChange: (\n    resourceNames:\n      | Record<string, string>\n      | ((prev: Record<string, string>) => Record<string, string>),\n  ) => void;\n  onKeyDown?: (event: React.KeyboardEvent) => void;\n  placeholder?: string;\n  disabled?: boolean;\n  className?: string;\n  /** Submit handler for Enter key behavior */\n  onSubmit: (e: React.FormEvent) => Promise<void>;\n  /** Called when an image is pasted into the editor */\n  onAddImage: (file: File) => Promise<void>;\n  /** Called when resource search query changes (for \"@\" mentions) - parent should update `resources` prop */\n  onSearchResources: (query: string) => void;\n  /** Current list of resources to show in the \"@\" suggestion menu (controlled) */\n  resources: ResourceItem[];\n  /** Called when prompt search query changes (for \"/\" commands) - parent should update `prompts` prop */\n  onSearchPrompts: (query: string) => void;\n  /** Current list of prompts to show in the \"/\" suggestion menu (controlled) */\n  prompts: PromptItem[];\n  /** Called when a resource is selected from the \"@\" menu */\n  onResourceSelect: (item: ResourceItem) => void;\n  /** Called when a prompt is selected from the \"/\" menu */\n  onPromptSelect: (item: PromptItem) => void;\n}\n\n/**\n * State for a suggestion popover.\n */\ninterface SuggestionState<T extends SuggestionItem> {\n  isOpen: boolean;\n  items: T[];\n  selectedIndex: number;\n  position: { top: number; left: number; lineHeight: number } | null;\n  command: ((item: T) => void) | null;\n}\n\n/**\n * Ref value for accessing suggestion state from TipTap callbacks.\n */\ninterface SuggestionRef<T extends SuggestionItem> {\n  state: SuggestionState<T>;\n  setState: (update: Partial<SuggestionState<T>>) => void;\n}\n\n/**\n * Utility function to convert TipTap clientRect to position coordinates.\n * Includes line height for proper spacing when popup flips above cursor.\n */\nfunction getPositionFromClientRect(\n  clientRect?: (() => DOMRect | null) | null,\n): { top: number; left: number; lineHeight: number } | null {\n  if (!clientRect) return null;\n  const rect = clientRect();\n  if (!rect) return null;\n  const lineHeight = rect.height || 20; // Fallback to 20px if height not available\n  return { top: rect.bottom, left: rect.left, lineHeight };\n}\n\n/**\n * Props for the generic suggestion popover.\n */\ninterface SuggestionPopoverProps<T extends SuggestionItem> {\n  state: SuggestionState<T>;\n  onClose: () => void;\n  defaultIcon: React.ReactNode;\n  emptyMessage: string;\n  /** Whether to use monospace font for the secondary text (id) */\n  monoSecondary?: boolean;\n}\n\n/**\n * Generic popover component for suggestions (@resources and /prompts).\n */\nfunction SuggestionPopover<T extends SuggestionItem>({\n  state,\n  onClose,\n  defaultIcon,\n  emptyMessage,\n  monoSecondary = false,\n}: SuggestionPopoverProps<T>) {\n  if (!state.isOpen || !state.position) return null;\n\n  const sideOffset = state.position.lineHeight + 4;\n\n  return (\n    <Popover.Root\n      open={state.isOpen}\n      onOpenChange={(open) => !open && onClose()}\n    >\n      <Popover.Anchor asChild>\n        <div\n          style={{\n            position: \"fixed\",\n            top: `${state.position.top}px`,\n            left: `${state.position.left}px`,\n            width: 0,\n            height: 0,\n            pointerEvents: \"none\",\n          }}\n        />\n      </Popover.Anchor>\n      <Popover.Content\n        side=\"bottom\"\n        align=\"start\"\n        sideOffset={sideOffset}\n        className=\"z-50 w-96 rounded-md border bg-popover p-0 shadow-md animate-in fade-in-0 zoom-in-95\"\n        onOpenAutoFocus={(e) => e.preventDefault()}\n        onCloseAutoFocus={(e) => e.preventDefault()}\n        onEscapeKeyDown={(e) => {\n          e.preventDefault();\n          onClose();\n        }}\n      >\n        {state.items.length === 0 ? (\n          <div className=\"px-3 py-2 text-sm text-muted-foreground\">\n            {emptyMessage}\n          </div>\n        ) : (\n          <div className=\"flex flex-col gap-0.5 p-1\">\n            {state.items.map((item, index) => (\n              <button\n                key={item.id}\n                type=\"button\"\n                className={cn(\n                  \"flex items-start gap-2 px-2 py-2 text-sm rounded-md text-left\",\n                  \"hover:bg-accent hover:text-accent-foreground transition-colors\",\n                  index === state.selectedIndex &&\n                    \"bg-accent text-accent-foreground\",\n                )}\n                onClick={() => state.command?.(item)}\n              >\n                {item.icon ?? defaultIcon}\n                <div className=\"flex-1 min-w-0\">\n                  <div className=\"font-medium truncate\">{item.name}</div>\n                  <div\n                    className={cn(\n                      \"text-xs text-muted-foreground truncate\",\n                      monoSecondary && \"font-mono\",\n                    )}\n                  >\n                    {item.id}\n                  </div>\n                </div>\n              </button>\n            ))}\n          </div>\n        )}\n      </Popover.Content>\n    </Popover.Root>\n  );\n}\n\n/**\n * Internal helper to check if a mention exists in a raw TipTap Editor.\n */\nfunction checkMentionExists(editor: Editor, label: string): boolean {\n  if (!editor.state?.doc) return false;\n  let exists = false;\n  editor.state.doc.descendants((node) => {\n    if (node.type.name === \"mention\") {\n      const mentionLabel = node.attrs.label as string;\n      if (mentionLabel === label) {\n        exists = true;\n        return false;\n      }\n    }\n    return true;\n  });\n  return exists;\n}\n\n/**\n * Creates the resource mention configuration for TipTap Mention extension.\n * The items() function triggers the search - actual items come from props via stateRef.\n */\nfunction createResourceMentionConfig(\n  onSearchChange: (query: string) => void,\n  onSelect: (item: ResourceItem) => void,\n  stateRef: React.MutableRefObject<SuggestionRef<ResourceItem>>,\n): Omit<SuggestionOptions, \"editor\"> {\n  return {\n    char: \"@\",\n    items: ({ query }) => {\n      onSearchChange(query);\n      return [];\n    },\n\n    render: () => {\n      const createWrapCommand =\n        (\n          editor: Editor,\n          tiptapCommand: (attrs: { id: string; label: string }) => void,\n        ) =>\n        (item: ResourceItem) => {\n          if (checkMentionExists(editor, item.name)) return;\n          tiptapCommand({ id: item.id, label: item.name });\n          onSelect(item);\n        };\n\n      return {\n        onStart: (props) => {\n          stateRef.current.setState({\n            isOpen: true,\n            selectedIndex: 0,\n            position: getPositionFromClientRect(props.clientRect),\n            command: createWrapCommand(props.editor, props.command),\n          });\n        },\n        onUpdate: (props) => {\n          stateRef.current.setState({\n            position: getPositionFromClientRect(props.clientRect),\n            command: createWrapCommand(props.editor, props.command),\n            selectedIndex: 0,\n          });\n        },\n        onKeyDown: ({ event }) => {\n          const { state, setState } = stateRef.current;\n          if (!state.isOpen) return false;\n\n          const handlers: Record<string, () => boolean> = {\n            ArrowUp: () => {\n              if (state.items.length === 0) return false;\n              setState({\n                selectedIndex:\n                  (state.selectedIndex - 1 + state.items.length) %\n                  state.items.length,\n              });\n              return true;\n            },\n            ArrowDown: () => {\n              if (state.items.length === 0) return false;\n              setState({\n                selectedIndex: (state.selectedIndex + 1) % state.items.length,\n              });\n              return true;\n            },\n            Enter: () => {\n              const item = state.items[state.selectedIndex];\n              if (item && state.command) {\n                state.command(item);\n                return true;\n              }\n              return false;\n            },\n            Escape: () => {\n              setState({ isOpen: false });\n              return true;\n            },\n          };\n\n          const handler = handlers[event.key];\n          if (handler) {\n            event.preventDefault();\n            return handler();\n          }\n          return false;\n        },\n        onExit: () => {\n          stateRef.current.setState({ isOpen: false });\n        },\n      };\n    },\n  };\n}\n\n/**\n * Creates a custom TipTap extension for prompt commands using the Suggestion plugin.\n * The items() function triggers the search - actual items come from props via stateRef.\n */\nfunction createPromptCommandExtension(\n  onSearchChange: (query: string) => void,\n  onSelect: (item: PromptItem) => void,\n  stateRef: React.MutableRefObject<Suggestio\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/components/tambo/thread-container.tsx",
      "path": "src/components/tambo/thread-container.tsx",
      "name": "thread-container.tsx",
      "mimeType": "text/plain",
      "text": "import { cn } from \"@/lib/utils\";\nimport {\n  useCanvasDetection,\n  usePositioning,\n  useMergeRefs,\n} from \"@/lib/thread-hooks\";\nimport * as React from \"react\";\nimport { useRef } from \"react\";\n\n/**\n * Props for the ThreadContainer component\n */\nexport interface ThreadContainerProps extends React.HTMLAttributes<HTMLDivElement> {\n  /**\n   * Whether to disable automatic sidebar spacing.\n   * When true, the component will not add margins for the sidebar.\n   * Useful when the sidebar is positioned externally (e.g., in a flex container).\n   * @default false\n   */\n  disableSidebarSpacing?: boolean;\n}\n\n/**\n * A responsive container component for message threads that handles\n * positioning relative to canvas space and sidebar.\n *\n * It automatically detects canvas presence and adjusts layout accordingly.\n */\nexport const ThreadContainer = React.forwardRef<\n  HTMLDivElement,\n  ThreadContainerProps\n>(({ className, children, disableSidebarSpacing = false, ...props }, ref) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { hasCanvasSpace, canvasIsOnLeft } = useCanvasDetection(containerRef);\n  const { isLeftPanel, historyPosition } = usePositioning(\n    className,\n    canvasIsOnLeft,\n    hasCanvasSpace,\n  );\n  const mergedRef = useMergeRefs<HTMLDivElement | null>(ref, containerRef);\n\n  return (\n    <div\n      ref={mergedRef}\n      className={cn(\n        // Base layout and styling\n        \"flex flex-col overflow-hidden bg-background\",\n        \"h-full\",\n\n        // Add smooth transitions for layout changes\n        \"transition-all duration-200 ease-in-out\",\n\n        // Sidebar spacing based on history position (unless disabled)\n        !disableSidebarSpacing &&\n          (historyPosition === \"right\"\n            ? \"mr-[var(--sidebar-width,16rem)]\"\n            : \"ml-[var(--sidebar-width,16rem)]\"),\n\n        // Width constraints based on canvas presence (unless sidebar spacing disabled)\n        !disableSidebarSpacing &&\n          (hasCanvasSpace\n            ? \"max-w-3xl\"\n            : \"w-[calc(100%-var(--sidebar-width,16rem))]\"),\n        disableSidebarSpacing && \"flex-1\",\n\n        // Border styling when canvas is present\n        hasCanvasSpace && (canvasIsOnLeft ? \"border-l\" : \"border-r\"),\n        hasCanvasSpace && \"border-border\",\n\n        // Right alignment when specified\n        !isLeftPanel && \"ml-auto\",\n\n        // Custom classes passed via props\n        className,\n      )}\n      {...props}\n    >\n      {children}\n    </div>\n  );\n});\nThreadContainer.displayName = \"ThreadContainer\";\n\n/**\n * Hook that provides positioning context for thread containers\n *\n * @returns {Object} Object containing:\n *   - containerRef: Reference to container element\n *   - hasCanvasSpace: Whether canvas space is available\n *   - canvasIsOnLeft: Whether canvas is positioned on the left\n *   - isLeftPanel: Whether the container is positioned as a left panel\n *   - historyPosition: Position of history sidebar (\"left\" or \"right\")\n */\nexport function useThreadContainerContext() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const { hasCanvasSpace, canvasIsOnLeft } = useCanvasDetection(containerRef);\n  const { isLeftPanel, historyPosition } = usePositioning(\n    \"\",\n    canvasIsOnLeft,\n    hasCanvasSpace,\n  );\n\n  return {\n    containerRef,\n    hasCanvasSpace,\n    canvasIsOnLeft,\n    isLeftPanel,\n    historyPosition,\n  };\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/thread-content.tsx",
      "path": "src/components/tambo/thread-content.tsx",
      "name": "thread-content.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport {\n  Message,\n  MessageContent,\n  MessageImages,\n  MessageRenderedComponentArea,\n  ReasoningInfo,\n  ToolcallInfo,\n  type messageVariants,\n} from \"@/components/tambo/message\";\nimport { cn } from \"@/lib/utils\";\nimport { type TamboThreadMessage, useTambo } from \"@tambo-ai/react\";\nimport { type VariantProps } from \"class-variance-authority\";\nimport * as React from \"react\";\n\n/**\n * @typedef ThreadContentContextValue\n * @property {Array} messages - Array of message objects in the thread\n * @property {boolean} isGenerating - Whether a response is being generated\n * @property {string|undefined} generationStage - Current generation stage\n * @property {VariantProps<typeof messageVariants>[\"variant\"]} [variant] - Optional styling variant for messages\n */\ninterface ThreadContentContextValue {\n  messages: TamboThreadMessage[];\n  isGenerating: boolean;\n  generationStage?: string;\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n}\n\n/**\n * React Context for sharing thread data among sub-components.\n * @internal\n */\nconst ThreadContentContext =\n  React.createContext<ThreadContentContextValue | null>(null);\n\n/**\n * Hook to access the thread content context.\n * @returns {ThreadContentContextValue} The thread content context value.\n * @throws {Error} If used outside of ThreadContent.\n * @internal\n */\nconst useThreadContentContext = () => {\n  const context = React.useContext(ThreadContentContext);\n  if (!context) {\n    throw new Error(\n      \"ThreadContent sub-components must be used within a ThreadContent\",\n    );\n  }\n  return context;\n};\n\n/**\n * Props for the ThreadContent component.\n * Extends standard HTMLDivElement attributes.\n */\nexport interface ThreadContentProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Optional styling variant for the message container */\n  variant?: VariantProps<typeof messageVariants>[\"variant\"];\n  /** The child elements to render within the container. */\n  children?: React.ReactNode;\n}\n\n/**\n * The root container for thread content.\n * It establishes the context for its children using data from the Tambo hook.\n * @component ThreadContent\n * @example\n * ```tsx\n * <ThreadContent variant=\"solid\">\n *   <ThreadContent.Messages />\n * </ThreadContent>\n * ```\n */\nconst ThreadContent = React.forwardRef<HTMLDivElement, ThreadContentProps>(\n  ({ children, className, variant, ...props }, ref) => {\n    const { thread, generationStage, isIdle } = useTambo();\n    const isGenerating = !isIdle;\n\n    const contextValue = React.useMemo(\n      () => ({\n        messages: thread?.messages ?? [],\n        isGenerating,\n        generationStage,\n        variant,\n      }),\n      [thread?.messages, isGenerating, generationStage, variant],\n    );\n\n    return (\n      <ThreadContentContext.Provider value={contextValue}>\n        <div\n          ref={ref}\n          className={cn(\"w-full\", className)}\n          data-slot=\"thread-content-container\"\n          {...props}\n        >\n          {children}\n        </div>\n      </ThreadContentContext.Provider>\n    );\n  },\n);\nThreadContent.displayName = \"ThreadContent\";\n\n/**\n * Props for the ThreadContentMessages component.\n * Extends standard HTMLDivElement attributes.\n */\nexport type ThreadContentMessagesProps = React.HTMLAttributes<HTMLDivElement>;\n\n/**\n * Renders the list of messages in the thread.\n * Automatically connects to the context to display messages.\n * @component ThreadContent.Messages\n * @example\n * ```tsx\n * <ThreadContent>\n *   <ThreadContent.Messages />\n * </ThreadContent>\n * ```\n */\nconst ThreadContentMessages = React.forwardRef<\n  HTMLDivElement,\n  ThreadContentMessagesProps\n>(({ className, ...props }, ref) => {\n  const { messages, isGenerating, variant } = useThreadContentContext();\n\n  const filteredMessages = messages.filter(\n    (message) => message.role !== \"system\" && !message.parentMessageId,\n  );\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\"flex flex-col gap-2\", className)}\n      data-slot=\"thread-content-messages\"\n      {...props}\n    >\n      {filteredMessages.map((message, index) => {\n        return (\n          <div\n            key={\n              message.id ??\n              `${message.role}-${message.createdAt ?? `${index}`}-${message.content?.toString().substring(0, 10)}`\n            }\n            data-slot=\"thread-content-item\"\n          >\n            <Message\n              role={message.role === \"assistant\" ? \"assistant\" : \"user\"}\n              message={message}\n              variant={variant}\n              isLoading={isGenerating && index === filteredMessages.length - 1}\n              className={cn(\n                \"flex w-full\",\n                message.role === \"assistant\" ? \"justify-start\" : \"justify-end\",\n              )}\n            >\n              <div\n                className={cn(\n                  \"flex flex-col\",\n                  message.role === \"assistant\" ? \"w-full\" : \"max-w-3xl\",\n                )}\n              >\n                <ReasoningInfo />\n                <MessageImages />\n                <MessageContent\n                  className={\n                    message.role === \"assistant\"\n                      ? \"text-foreground font-sans\"\n                      : \"text-foreground bg-container hover:bg-backdrop font-sans\"\n                  }\n                />\n                <ToolcallInfo />\n                <MessageRenderedComponentArea className=\"w-full\" />\n              </div>\n            </Message>\n          </div>\n        );\n      })}\n    </div>\n  );\n});\nThreadContentMessages.displayName = \"ThreadContent.Messages\";\n\nexport { ThreadContent, ThreadContentMessages };\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/thread-dropdown.tsx",
      "path": "src/components/tambo/thread-dropdown.tsx",
      "name": "thread-dropdown.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport * as DropdownMenu from \"@radix-ui/react-dropdown-menu\";\nimport { useTamboThread, useTamboThreadList } from \"@tambo-ai/react\";\nimport { ChevronDownIcon, PlusIcon } from \"lucide-react\";\nimport * as React from \"react\";\nimport { useCallback } from \"react\";\n\n/**\n * Props for the ThreadDropdown component\n * @interface\n * @extends React.HTMLAttributes<HTMLDivElement>\n */\nexport interface ThreadDropdownProps extends React.HTMLAttributes<HTMLDivElement> {\n  /** Optional callback function called when the current thread changes */\n  onThreadChange?: () => void;\n}\n\n/**\n * A component that displays a dropdown menu for managing chat threads with keyboard shortcuts\n * @component\n * @example\n * ```tsx\n * <ThreadDropdown\n *   onThreadChange={() => console.log('Thread changed')}\n *   className=\"custom-styles\"\n * />\n * ```\n */\nexport const ThreadDropdown = React.forwardRef<\n  HTMLDivElement,\n  ThreadDropdownProps\n>(({ className, onThreadChange, ...props }, ref) => {\n  const { data: threads, isLoading, error, refetch } = useTamboThreadList();\n  const { switchCurrentThread, startNewThread } = useTamboThread();\n  const isMac =\n    typeof navigator !== \"undefined\" && navigator.platform.startsWith(\"Mac\");\n  const modKey = isMac ? \"\" : \"Alt\";\n\n  const handleNewThread = useCallback(\n    async (e?: React.MouseEvent) => {\n      if (e) {\n        e.stopPropagation();\n      }\n\n      try {\n        await startNewThread();\n        await refetch();\n        onThreadChange?.();\n      } catch (error) {\n        console.error(\"Failed to create new thread:\", error);\n      }\n    },\n    [onThreadChange, startNewThread, refetch],\n  );\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.altKey && event.shiftKey && event.key === \"n\") {\n        event.preventDefault();\n        void handleNewThread();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown);\n    };\n  }, [handleNewThread]);\n\n  const handleSwitchThread = async (threadId: string, e?: React.MouseEvent) => {\n    if (e) {\n      e.stopPropagation();\n    }\n\n    try {\n      switchCurrentThread(threadId);\n      onThreadChange?.();\n    } catch (error) {\n      console.error(\"Failed to switch thread:\", error);\n    }\n  };\n\n  return (\n    <div className={cn(\"relative\", className)} ref={ref} {...props}>\n      <DropdownMenu.Root>\n        <DropdownMenu.Trigger asChild>\n          <button\n            type=\"button\"\n            className=\"rounded-md px-1 flex items-center gap-2 text-sm border border-border bg-background hover:bg-accent hover:text-accent-foreground cursor-pointer transition-colors\"\n            aria-label=\"Thread History\"\n          >\n            <ChevronDownIcon className=\"h-4 w-4\" />\n          </button>\n        </DropdownMenu.Trigger>\n        <DropdownMenu.Portal>\n          <DropdownMenu.Content\n            className=\"z-50 min-w-[200px] overflow-hidden rounded-md border border-border bg-popover p-1 text-popover-foreground shadow-md\"\n            side=\"right\"\n            align=\"start\"\n            sideOffset={5}\n          >\n            <DropdownMenu.Item\n              className=\"relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\"\n              onSelect={(e: Event) => {\n                e.preventDefault();\n                void handleNewThread();\n              }}\n            >\n              <div className=\"flex items-center\">\n                <PlusIcon className=\"mr-2 h-4 w-4\" />\n                <span>New Thread</span>\n              </div>\n              <span\n                className=\"ml-auto text-xs text-muted-foreground\"\n                suppressHydrationWarning\n              >\n                {modKey}++N\n              </span>\n            </DropdownMenu.Item>\n\n            <DropdownMenu.Separator className=\"my-1 h-px bg-border\" />\n\n            <ThreadListContent\n              isLoading={isLoading}\n              error={error}\n              threads={threads}\n              onSwitchThread={handleSwitchThread}\n            />\n          </DropdownMenu.Content>\n        </DropdownMenu.Portal>\n      </DropdownMenu.Root>\n    </div>\n  );\n});\nThreadDropdown.displayName = \"ThreadDropdown\";\n\n/**\n * Internal component to render thread list content based on loading/error/empty states\n */\nfunction ThreadListContent({\n  isLoading,\n  error,\n  threads,\n  onSwitchThread,\n}: {\n  isLoading: boolean;\n  error: Error | null;\n  threads: { items: { id: string }[] } | null | undefined;\n  onSwitchThread: (threadId: string) => void;\n}) {\n  if (isLoading) {\n    return (\n      <DropdownMenu.Item\n        className=\"px-2 py-1.5 text-sm text-muted-foreground\"\n        disabled\n      >\n        Loading threads...\n      </DropdownMenu.Item>\n    );\n  }\n  if (error) {\n    return (\n      <DropdownMenu.Item\n        className=\"px-2 py-1.5 text-sm text-destructive\"\n        disabled\n      >\n        Error loading threads\n      </DropdownMenu.Item>\n    );\n  }\n  if (threads?.items.length === 0) {\n    return (\n      <DropdownMenu.Item\n        className=\"px-2 py-1.5 text-sm text-muted-foreground\"\n        disabled\n      >\n        No previous threads\n      </DropdownMenu.Item>\n    );\n  }\n  return (\n    <>\n      {threads?.items.map((thread) => (\n        <DropdownMenu.Item\n          key={thread.id}\n          className=\"relative flex cursor-pointer select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50\"\n          onSelect={(e: Event) => {\n            e.preventDefault();\n            void onSwitchThread(thread.id);\n          }}\n        >\n          <span className=\"truncate max-w-[180px]\">\n            {`Thread ${thread.id.substring(0, 8)}`}\n          </span>\n        </DropdownMenu.Item>\n      ))}\n    </>\n  );\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/components/tambo/thread-history.tsx",
      "path": "src/components/tambo/thread-history.tsx",
      "name": "thread-history.tsx",
      "mimeType": "text/plain",
      "text": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport * as DropdownMenu from \"@radix-ui/react-dropdown-menu\";\nimport {\n  type TamboThread,\n  useTamboThread,\n  useTamboThreadList,\n} from \"@tambo-ai/react\";\nimport {\n  ArrowLeftToLine,\n  ArrowRightToLine,\n  MoreHorizontal,\n  Pencil,\n  PlusIcon,\n  SearchIcon,\n  Sparkles,\n} from \"lucide-react\";\nimport React, { useMemo } from \"react\";\n\n/**\n * Context for sharing thread history state and functions\n */\ninterface ThreadHistoryContextValue {\n  threads: { items?: TamboThread[] } | null | undefined;\n  isLoading: boolean;\n  error: Error | null;\n  refetch: () => Promise<unknown>;\n  currentThread: TamboThread;\n  switchCurrentThread: (threadId: string) => void;\n  startNewThread: () => void;\n  searchQuery: string;\n  setSearchQuery: React.Dispatch<React.SetStateAction<string>>;\n  isCollapsed: boolean;\n  setIsCollapsed: React.Dispatch<React.SetStateAction<boolean>>;\n  onThreadChange?: () => void;\n  position?: \"left\" | \"right\";\n  updateThreadName: (newName: string, threadId?: string) => Promise<void>;\n  generateThreadName: (threadId: string) => Promise<TamboThread>;\n}\n\nconst ThreadHistoryContext =\n  React.createContext<ThreadHistoryContextValue | null>(null);\n\nconst useThreadHistoryContext = () => {\n  const context = React.useContext(ThreadHistoryContext);\n  if (!context) {\n    throw new Error(\n      \"ThreadHistory components must be used within ThreadHistory\",\n    );\n  }\n  return context;\n};\n\n/**\n * Root component that provides context for thread history\n */\ninterface ThreadHistoryProps extends React.HTMLAttributes<HTMLDivElement> {\n  onThreadChange?: () => void;\n  children?: React.ReactNode;\n  defaultCollapsed?: boolean;\n  position?: \"left\" | \"right\";\n}\n\nconst ThreadHistory = React.forwardRef<HTMLDivElement, ThreadHistoryProps>(\n  (\n    {\n      className,\n      onThreadChange,\n      defaultCollapsed = true,\n      position = \"left\",\n      children,\n      ...props\n    },\n    ref,\n  ) => {\n    const [searchQuery, setSearchQuery] = React.useState(\"\");\n    const [isCollapsed, setIsCollapsed] = React.useState(defaultCollapsed);\n    const [shouldFocusSearch, setShouldFocusSearch] = React.useState(false);\n\n    const { data: threads, isLoading, error, refetch } = useTamboThreadList();\n\n    const {\n      switchCurrentThread,\n      startNewThread,\n      thread: currentThread,\n      updateThreadName,\n      generateThreadName,\n    } = useTamboThread();\n\n    // Update CSS variable when sidebar collapses/expands\n    React.useEffect(() => {\n      const sidebarWidth = isCollapsed ? \"3rem\" : \"16rem\";\n      document.documentElement.style.setProperty(\n        \"--sidebar-width\",\n        sidebarWidth,\n      );\n    }, [isCollapsed]);\n\n    // Focus search input when expanded from collapsed state\n    React.useEffect(() => {\n      if (!isCollapsed && shouldFocusSearch) {\n        setShouldFocusSearch(false);\n      }\n    }, [isCollapsed, shouldFocusSearch]);\n\n    const contextValue = React.useMemo(\n      () => ({\n        threads,\n        isLoading,\n        error,\n        refetch,\n        currentThread,\n        switchCurrentThread,\n        startNewThread,\n        searchQuery,\n        setSearchQuery,\n        isCollapsed,\n        setIsCollapsed,\n        onThreadChange,\n        position,\n        updateThreadName,\n        generateThreadName,\n      }),\n      [\n        threads,\n        isLoading,\n        error,\n        refetch,\n        currentThread,\n        switchCurrentThread,\n        startNewThread,\n        searchQuery,\n        isCollapsed,\n        onThreadChange,\n        position,\n        updateThreadName,\n        generateThreadName,\n      ],\n    );\n\n    return (\n      <ThreadHistoryContext.Provider\n        value={contextValue as ThreadHistoryContextValue}\n      >\n        <div\n          ref={ref}\n          className={cn(\n            \"border-flat bg-container h-full transition-all duration-300 flex-none\",\n            position === \"left\" ? \"border-r\" : \"border-l\",\n            isCollapsed ? \"w-12\" : \"w-64\",\n            className,\n          )}\n          {...props}\n        >\n          <div\n            className={cn(\n              \"flex flex-col h-full\",\n              isCollapsed ? \"py-4 px-2\" : \"p-4\",\n            )} // py-4 px-2 is for better alignment when isCollapsed\n          >\n            {children}\n          </div>\n        </div>\n      </ThreadHistoryContext.Provider>\n    );\n  },\n);\nThreadHistory.displayName = \"ThreadHistory\";\n\n/**\n * Header component with title and collapse toggle\n */\nconst ThreadHistoryHeader = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const {\n    isCollapsed,\n    setIsCollapsed,\n    position = \"left\",\n  } = useThreadHistoryContext();\n\n  return (\n    <div\n      ref={ref}\n      className={cn(\n        \"flex items-center mb-4 relative\",\n        isCollapsed ? \"p-1\" : \"p-1\",\n        className,\n      )}\n      {...props}\n    >\n      <h2\n        className={cn(\n          \"text-sm text-muted-foreground whitespace-nowrap \",\n          isCollapsed\n            ? \"opacity-0 max-w-0 overflow-hidden \"\n            : \"opacity-100 max-w-none transition-all duration-300 delay-75\",\n        )}\n      >\n        Tambo Conversations\n      </h2>\n      <button\n        onClick={() => setIsCollapsed(!isCollapsed)}\n        className={cn(\n          `bg-container p-1 hover:bg-backdrop transition-colors rounded-md cursor-pointer absolute flex items-center justify-center`,\n          position === \"left\" ? \"right-1\" : \"left-0\",\n        )}\n        aria-label={isCollapsed ? \"Expand sidebar\" : \"Collapse sidebar\"}\n      >\n        {isCollapsed ? (\n          <ArrowRightToLine\n            className={cn(\"h-4 w-4\", position === \"right\" && \"rotate-180\")}\n          />\n        ) : (\n          <ArrowLeftToLine\n            className={cn(\"h-4 w-4\", position === \"right\" && \"rotate-180\")}\n          />\n        )}\n      </button>\n    </div>\n  );\n});\nThreadHistoryHeader.displayName = \"ThreadHistory.Header\";\n\n/**\n * Button to create a new thread\n */\nconst ThreadHistoryNewButton = React.forwardRef<\n  HTMLButtonElement,\n  React.ButtonHTMLAttributes<HTMLButtonElement>\n>(({ ...props }, ref) => {\n  const { isCollapsed, startNewThread, refetch, onThreadChange } =\n    useThreadHistoryContext();\n\n  const handleNewThread = React.useCallback(\n    async (e?: React.MouseEvent) => {\n      if (e) e.stopPropagation();\n\n      try {\n        await startNewThread();\n        await refetch();\n        onThreadChange?.();\n      } catch (error) {\n        console.error(\"Failed to create new thread:\", error);\n      }\n    },\n    [startNewThread, refetch, onThreadChange],\n  );\n\n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if (event.altKey && event.shiftKey && event.key === \"n\") {\n        event.preventDefault();\n        void handleNewThread();\n      }\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [handleNewThread]);\n\n  return (\n    <button\n      ref={ref}\n      onClick={handleNewThread}\n      className={cn(\n        \"flex items-center rounded-md mb-4 hover:bg-backdrop transition-colors cursor-pointer relative\",\n        isCollapsed ? \"p-1 justify-center\" : \"p-2 gap-2\",\n      )}\n      title=\"New thread\"\n      {...props}\n    >\n      <PlusIcon className=\"h-4 w-4 bg-green-600 rounded-full text-white\" />\n      <span\n        className={cn(\n          \"text-sm font-medium whitespace-nowrap absolute left-8 pb-[2px] \",\n          isCollapsed\n            ? \"opacity-0 max-w-0 overflow-hidden pointer-events-none\"\n            : \"opacity-100 transition-all duration-300 delay-100\",\n        )}\n      >\n        New thread\n      </span>\n    </button>\n  );\n});\nThreadHistoryNewButton.displayName = \"ThreadHistory.NewButton\";\n\n/**\n * Search input for filtering threads\n */\nconst ThreadHistorySearch = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const { isCollapsed, setIsCollapsed, searchQuery, setSearchQuery } =\n    useThreadHistoryContext();\n  const searchInputRef = React.useRef<HTMLInputElement>(null);\n\n  const expandOnSearch = () => {\n    if (isCollapsed) {\n      setIsCollapsed(false);\n      setTimeout(() => {\n        searchInputRef.current?.focus();\n      }, 300); // Wait for animation\n    }\n  };\n\n  return (\n    <div ref={ref} className={cn(\"mb-4 relative\", className)} {...props}>\n      {/*visible when collapsed */}\n      <button\n        onClick={expandOnSearch}\n        className={cn(\n          \"p-1 hover:bg-backdrop rounded-md cursor-pointer absolute left-1/2 -translate-x-1/2\",\n          isCollapsed\n            ? \"opacity-100 pointer-events-auto transition-all duration-300\"\n            : \"opacity-0 pointer-events-none\",\n        )}\n        title=\"Search threads\"\n      >\n        <SearchIcon className=\"h-4 w-4 text-gray-400\" />\n      </button>\n\n      {/*visible when expanded with delay */}\n\n      <div\n        className={cn(\n          //using this as wrapper\n          isCollapsed\n            ? \"opacity-0 pointer-events-none\"\n            : \"opacity-100 delay-100 transition-all duration-500\",\n        )}\n      >\n        <div className=\"absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none\">\n          <SearchIcon className=\"h-4 w-4 text-gray-400\" />\n        </div>\n        <input\n          ref={searchInputRef}\n          type=\"text\"\n          className=\"pl-10 pr-4 py-2 w-full text-sm rounded-md bg-container focus:outline-none\"\n          placeholder=\"Search...\"\n          value={searchQuery}\n          onChange={(e) => setSearchQuery(e.target.value)}\n        />\n      </div>\n    </div>\n  );\n});\nThreadHistorySearch.displayName = \"ThreadHistory.Search\";\n\n/**\n * List of thread items\n */\nconst ThreadHistoryList = React.forwardRef<\n  HTMLDivElement,\n  React.HTMLAttributes<HTMLDivElement>\n>(({ className, ...props }, ref) => {\n  const {\n    threads,\n    isLoading,\n    error,\n    isCollapsed,\n    searchQuery,\n    currentThread,\n    switchCurrentThread,\n    onThreadChange,\n    updateThreadName,\n    generateThreadName,\n    refetch,\n  } = useThreadHistoryContext();\n\n  const [editingThread, setEditingThread] = React.useState<TamboThread | null>(\n    null,\n  );\n  const [newName, setNewName] = React.useState(\"\");\n  const inputRef = React.useRef<HTMLInputElement>(null);\n\n  // Handle click outside name editing input\n  React.useEffect(() => {\n    const handleClickOutside = (event: MouseEvent) => {\n      if (\n        editingThread &&\n        inputRef.current &&\n        !inputRef.current.contains(event.target as Node)\n      ) {\n        setEditingThread(null);\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => {\n      document.removeEventListener(\"mousedown\", handleClickOutside);\n    };\n  }, [editingThread]);\n\n  // Focus input when entering edit mode\n  React.useEffect(() => {\n    if (editingThread) {\n      const timer = setTimeout(() => {\n        inputRef.current?.focus();\n      }, 100);\n      return () => clearTimeout(timer);\n    }\n  }, [editingThread]);\n\n  const handleKeyDown = (e: React.KeyboardEvent) => {\n    if (e.key === \"Escape\") {\n      setEditingThread(null);\n    }\n  };\n\n  // Filter threads based on search query\n  const filteredThreads = useMemo(() => {\n    // While collapsed we do not need the list, avoid extra work.\n    if (isCollapsed) return [];\n\n    if (!threads?.items) return [];\n\n    const query = searchQuery.toLowerCase();\n    return threads.items.filter((thread: TamboThread) => {\n      const nameMatches = thread.name?.toLowerCase().includes(query) ?? false;\n      const idMatches = thread.id.toLowerCase().includes(query);\n\n      return idMatches ? true : nameMatches;\n    });\n  }, [isCollapsed, threads, searchQuery]);\n\n  const handleSwitchThread = async (threadId: string, e?: React.MouseEvent) => {\n    if (e) e.stopPropagation();\n\n    try {\n      switchCurrentThread(threadId);\n      onThreadChange?.();\n    } catch (error) {\n      console.\n\n/* content truncated */",
      "truncated": true
    },
    {
      "uri": "file:///src/helpers/calculateWinner.js",
      "path": "src/helpers/calculateWinner.js",
      "name": "calculateWinner.js",
      "mimeType": "text/plain",
      "text": "function calculateWinner(squares) {\r\n    const lines = [\r\n      [0, 1, 2],\r\n      [3, 4, 5],\r\n      [6, 7, 8],\r\n      [0, 3, 6],\r\n      [1, 4, 7],\r\n      [2, 5, 8],\r\n      [0, 4, 8],\r\n      [2, 4, 6],\r\n    ];\r\n    for (let i = 0; i < lines.length; i++) {\r\n      const [a, b, c] = lines[i];\r\n      if (squares[a] && squares[a] === squares[b] && squares[a] === squares[c]) {\r\n        return squares[a];\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  export default calculateWinner;",
      "truncated": false
    },
    {
      "uri": "file:///src/index.css",
      "path": "src/index.css",
      "name": "index.css",
      "mimeType": "text/css",
      "text": "@import url(\"https://fonts.googleapis.com/css2?family=Seymour+One&display=swap\");\r\n@import url(\"https://fonts.googleapis.com/css2?family=Sofia+Sans:wght@100;400&display=swap\");\r\n\r\n:root {\r\n  --game-font: \"Seymour One\", sans-serif;\r\n  --speech-font: \"Sofia Sans\", sans-serif;\r\n  --dark-purple: rgb(18, 22, 75);\r\n  --dark-blue: rgb(42, 118, 180);\r\n  --light-blue: rgba(121, 185, 255, 255);\r\n  --white: rgb(255, 255, 255);\r\n  --light-grey: rgb(221, 221, 221);\r\n}\r\n\r\n*,\r\n*::before,\r\n*::after {\r\n  box-sizing: border-box;\r\n}\r\n\r\n* {\r\n  margin: 0;\r\n  padding: 0;\r\n}\r\nhtml {\r\n  min-height: 100%;\r\n}\r\nbody {\r\n  -ms-overflow-style: none; /* for Internet Explorer, Edge */\r\n  scrollbar-width: none; /* for Firefox */\r\n  overflow-y: scroll;\r\n  line-height: 1.5;\r\n  -webkit-font-smoothing: antialiased;\r\n  height: 100vh;\r\n}\r\nbody::-webkit-scrollbar {\r\n  display: none; /* for Chrome, Safari, and Opera */\r\n}\r\n\r\nimg,\r\npicture,\r\nvideo,\r\ncanvas,\r\nsvg {\r\n  display: block;\r\n  max-width: 100%;\r\n}\r\nimg {\r\n  display: block;\r\n}\r\n\r\nul,\r\nol,\r\nli {\r\n  padding: 0;\r\n  margin: 0;\r\n}\r\ninput,\r\nbutton,\r\ntextarea,\r\nselect {\r\n  font: inherit;\r\n}\r\np,\r\nh1,\r\nh2,\r\nh3,\r\nh4,\r\nh5,\r\nh6 {\r\n  overflow-wrap: break-word;\r\n}\r\n\r\n#root,\r\n#__next {\r\n  isolation: isolate;\r\n}\r\n\r\nmain {\r\n  position: relative;\r\n  min-height: 100%;\r\n  background-color: var(--light-blue);\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: center;\r\n}\r\nh1 {\r\n  font-family: var(--game-font);\r\n  color: var(--dark-purple);\r\n  font-size: 6vw;\r\n  letter-spacing: 1px;\r\n  padding: 1rem 1rem 6rem 1rem;\r\n}\r\n.game-board {\r\n  position: relative;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  padding: 25px;\r\n  font-size: 30px;\r\n  font-weight: bold;\r\n  color: var(--white);\r\n  transition:\r\n    margin-top 0.3s ease,\r\n    margin-left 0.3s ease,\r\n    box-shadow 0.3s ease;\r\n  background: var(--light-blue);\r\n}\r\n.game-section {\r\n  display: flex;\r\n  flex-direction: column;\r\n  gap: 1rem;\r\n  align-items: center;\r\n}\r\n.restart {\r\n  background-color: transparent;\r\n  padding: 0.5rem 4rem;\r\n  cursor: pointer;\r\n  border: 1px solid var(--dark-purple);\r\n  background-color: var(--dark-purple);\r\n  color: var(--white);\r\n  font-family: var(--speech-font);\r\n  font-weight: 400;\r\n  border-radius: 5px;\r\n  transition: all ease-in-out 0.3s;\r\n}\r\n.status {\r\n  margin-bottom: 10px;\r\n}\r\n\r\n.square {\r\n  background: var(--white);\r\n  border: 10px solid var(--dark-purple);\r\n  cursor: pointer;\r\n  float: left;\r\n  font-size: 6vw;\r\n  font-weight: bold;\r\n  line-height: 34px;\r\n  height: 8rem;\r\n  margin-right: -1px;\r\n  margin-top: -1px;\r\n  padding: 0;\r\n  text-align: center;\r\n  width: 8rem;\r\n  color: var(--dark-purple);\r\n  font-family: var(--game-font);\r\n}\r\n\r\n.square:focus {\r\n  outline: none;\r\n}\r\n\r\n.game {\r\n  display: grid;\r\n  grid-template-columns: repeat(2, 1fr);\r\n  max-width: 1200px;\r\n  width: 100%;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n}\r\n\r\n.game img {\r\n  max-width: 35rem;\r\n  width: 100%;\r\n  position: relative;\r\n  object-fit: contain;\r\n  min-width: 20rem;\r\n  margin: 0 auto;\r\n}\r\n\r\n.game-info {\r\n  position: absolute;\r\n}\r\n\r\n.player-x {\r\n  margin-left: 3rem;\r\n}\r\n\r\n.player-o {\r\n  margin-left: 23rem;\r\n  margin-top: -3rem;\r\n}\r\n\r\n.player-x,\r\n.player-o {\r\n  position: absolute;\r\n  z-index: 999;\r\n  transform: translatey(0px);\r\n  -webkit-animation: float 5s ease-in-out infinite;\r\n  animation: float 5s ease-in-out infinite;\r\n  mix-blend-mode: multiply;\r\n  text-align: center;\r\n  letter-spacing: 1px;\r\n  color: var(--dark-purple);\r\n  padding: 1rem 3rem;\r\n  border-radius: 11px;\r\n  width: max-content;\r\n  box-shadow: 20px 20px var(--dark-blue);\r\n  font-size: 2.5vw;\r\n  background-color: var(--light-grey);\r\n  font-family: var(--speech-font);\r\n}\r\n\r\n.player-x:after,\r\n.player-o:after {\r\n  z-index: 999;\r\n  transform: translatey(0px);\r\n  -webkit-animation: float2 5s ease-in-out infinite;\r\n  animation: float2 5s ease-in-out infinite;\r\n  content: \".\";\r\n  text-align: left;\r\n  font-size: 8vw;\r\n  width: 55px;\r\n  height: 11px;\r\n  line-height: 30px;\r\n  border-radius: 11px;\r\n  background-color: var(--light-grey);\r\n  position: absolute;\r\n  display: block;\r\n  bottom: -30px;\r\n  left: 0;\r\n  box-shadow: 22px 22px var(--dark-blue);\r\n  z-index: -2;\r\n}\r\n\r\n@-webkit-keyframes float {\r\n  0% {\r\n    transform: translatey(0px);\r\n  }\r\n  50% {\r\n    transform: translatey(-20px);\r\n  }\r\n  100% {\r\n    transform: translatey(0px);\r\n  }\r\n}\r\n\r\n@keyframes float {\r\n  0% {\r\n    transform: translatey(0px);\r\n  }\r\n  50% {\r\n    transform: translatey(-20px);\r\n  }\r\n  100% {\r\n    transform: translatey(0px);\r\n  }\r\n}\r\n@-webkit-keyframes float2 {\r\n  0% {\r\n    line-height: 30px;\r\n    transform: translatey(0px);\r\n  }\r\n  55% {\r\n    transform: translatey(-20px);\r\n  }\r\n  60% {\r\n    line-height: 10px;\r\n  }\r\n  100% {\r\n    line-height: 30px;\r\n    transform: translatey(0px);\r\n  }\r\n}\r\n@keyframes float2 {\r\n  0% {\r\n    line-height: 30px;\r\n    transform: translatey(0px);\r\n  }\r\n  55% {\r\n    transform: translatey(-20px);\r\n  }\r\n  60% {\r\n    line-height: 10px;\r\n  }\r\n  100% {\r\n    line-height: 30px;\r\n    transform: translatey(0px);\r\n  }\r\n}\r\n\r\n@media (hover: hover) {\r\n  .restart:hover {\r\n    transition: all ease-in-out 0.3s;\r\n    background-color: var(--dark-blue);\r\n    border-color: var(--dark-blue);\r\n  }\r\n}\r\n\r\n@media screen and (max-width: 900px) {\r\n  .game {\r\n    grid-template-columns: 1fr;\r\n    margin-bottom: 3rem;\r\n  }\r\n}\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/index.js",
      "path": "src/index.js",
      "name": "index.js",
      "mimeType": "text/plain",
      "text": "import React from 'react'\nimport ReactDOM from 'react-dom/client'\nimport './index.css'\nimport { BrowserRouter as Router, Routes, Route } from \"react-router-dom\";\nimport { TamboProvider, useTamboThread, useTamboThreadInput } from \"@tambo-ai/react\";\nimport calculateWinner from './helpers/calculateWinner'\nimport Board from './components/board/Board'\nimport GameInfo from './components/game-info/GameInfo'\n\nconst PROJECT_CONTEXT_ENDPOINT = `${process.env.PUBLIC_URL || \"\"}/project-context.json`;\n\nlet projectContextPromise;\n\nfunction getFallbackProjectContext() {\n  return {\n    generatedAt: null,\n    summary: \"No local project context is available.\",\n    resources: [],\n  };\n}\n\nasync function loadProjectContext() {\n  if (!projectContextPromise) {\n    projectContextPromise = fetch(PROJECT_CONTEXT_ENDPOINT)\n      .then((response) => {\n        if (!response.ok) throw new Error(\"project context not found\");\n        return response.json();\n      })\n      .catch(() => getFallbackProjectContext());\n  }\n  return projectContextPromise;\n}\n\nasync function listProjectResources(search) {\n  const context = await loadProjectContext();\n  const query = (search || \"\").toLowerCase().trim();\n\n  return context.resources\n    .filter((resource) => {\n      if (!query) return true;\n      return (\n        resource.uri.toLowerCase().includes(query) ||\n        resource.path.toLowerCase().includes(query) ||\n        resource.name.toLowerCase().includes(query)\n      );\n    })\n    .map((resource) => ({\n      uri: resource.uri,\n      name: resource.name,\n      description: `Project file ${resource.path}`,\n      mimeType: resource.mimeType,\n    }));\n}\n\nasync function getProjectResource(uri) {\n  const context = await loadProjectContext();\n  const resource = context.resources.find((item) => item.uri === uri);\n\n  if (!resource) {\n    return {\n      contents: [\n        {\n          uri,\n          mimeType: \"text/plain\",\n          text: `Resource not found for uri: ${uri}`,\n        },\n      ],\n    };\n  }\n\n  return {\n    contents: [\n      {\n        uri: resource.uri,\n        mimeType: resource.mimeType || \"text/plain\",\n        text: resource.text,\n      },\n    ],\n  };\n}\n\nfunction getMessageText(content) {\n  if (!content) return \"\";\n  if (typeof content === \"string\") return content;\n  if (!Array.isArray(content)) return String(content);\n\n  return content\n    .map((part) => {\n      if (!part || typeof part !== \"object\") return \"\";\n      if (part.type === \"text\" && typeof part.text === \"string\") return part.text;\n      return \"\";\n    })\n    .join(\"\\n\");\n}\n\nfunction ChatInterface() {\n  const { thread, streaming } = useTamboThread();\n  const { value, setValue, submit, isPending, error } = useTamboThreadInput();\n  const hasApiKey = Boolean(process.env.REACT_APP_TAMBO_API_KEY || process.env.NEXT_PUBLIC_TAMBO_API_KEY);\n\n  const onSubmit = async (event) => {\n    event.preventDefault();\n    if (!value.trim() || isPending) return;\n    await submit();\n  };\n\n  return (\n    <main style={{ maxWidth: 760, margin: \"2rem auto\", padding: \"0 1rem\" }}>\n      <h1>Tambo Chat</h1>\n      <p>Ask anything to test your Tambo setup.</p>\n      {!hasApiKey && (\n        <p style={{ color: \"crimson\" }}>\n          Missing API key. Set REACT_APP_TAMBO_API_KEY in .env.local and restart the dev server.\n        </p>\n      )}\n\n      <section style={{ border: \"1px solid #ddd\", borderRadius: 8, padding: 12, minHeight: 360 }}>\n        {thread.messages.length === 0 ? (\n          <p style={{ color: \"#666\" }}>No messages yet. Send your first prompt.</p>\n        ) : (\n          thread.messages.map((message) => (\n            <article key={message.id} style={{ marginBottom: 12 }}>\n              <strong style={{ textTransform: \"capitalize\" }}>{message.role}</strong>\n              <p style={{ whiteSpace: \"pre-wrap\", margin: \"0.4rem 0\" }}>{getMessageText(message.content)}</p>\n              {message.renderedComponent}\n            </article>\n          ))\n        )}\n      </section>\n\n      <form onSubmit={onSubmit} style={{ marginTop: 12, display: \"grid\", gap: 8 }}>\n        <textarea\n          value={value}\n          onChange={(e) => setValue(e.target.value)}\n          placeholder=\"Type a message...\"\n          rows={4}\n          style={{ width: \"100%\", padding: 10 }}\n        />\n        <button type=\"submit\" disabled={isPending} style={{ width: 120, padding: \"8px 12px\" }}>\n          {isPending ? \"Sending...\" : \"Send\"}\n        </button>\n      </form>\n\n      {streaming && <p>Generating response...</p>}\n      {error && <p style={{ color: \"crimson\" }}>{error.message || \"Failed to send message\"}</p>}\n    </main>\n  );\n}\n\nfunction ChatPage() {\n  return (\n    <TamboProvider\n      apiKey={process.env.REACT_APP_TAMBO_API_KEY || process.env.NEXT_PUBLIC_TAMBO_API_KEY || \"\"}\n      listResources={listProjectResources}\n      getResource={getProjectResource}\n      contextHelpers={{\n        project_summary: async () => {\n          const context = await loadProjectContext();\n          return context.summary;\n        },\n        assistant_instructions: async () => {\n          return \"Use project resources before answering codebase questions. If information is missing, ask for the exact file path.\";\n        },\n        project_context_version: async () => {\n          const context = await loadProjectContext();\n          return {\n            generatedAt: context.generatedAt,\n            resourceCount: context.resources.length,\n          };\n        },\n      }}\n    >\n      <ChatInterface />\n    </TamboProvider>\n  );\n}\n\nclass Game extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\r\n      history: [\r\n        {\r\n          squares: Array(9).fill(null),\r\n        },\r\n      ],\r\n      stepNumber: 0,\r\n      xIsNext: true,\r\n    }\r\n  }\r\n\r\n  handleClick(i) {\r\n    const history = this.state.history.slice(0, this.state.stepNumber + 1)\r\n    const current = history[history.length - 1]\r\n    const squares = current.squares.slice()\r\n    if (calculateWinner(squares) || squares[i]) {\r\n      return\r\n    }\r\n    squares[i] = this.state.xIsNext ? 'X' : 'O'\r\n    this.setState({\r\n      history: history.concat([\r\n        {\r\n          squares: squares,\r\n        },\r\n      ]),\r\n      stepNumber: history.length,\r\n      xIsNext: !this.state.xIsNext,\r\n    })\r\n  }\r\n\r\n  jumpTo(step) {\r\n    console.log(step)\r\n    this.setState({\r\n      stepNumber: step,\r\n      xIsNext: step % 2 === 0,\r\n    })\r\n  }\r\n\r\n  render() {\r\n    const history = this.state.history\r\n    const current = history[this.state.stepNumber]\r\n    const winner = calculateWinner(current.squares)\r\n    let status\r\n    if (winner) {\r\n      status = 'Winner: ' + winner\r\n    } else {\r\n      status = 'Next player: ' + (this.state.xIsNext ? 'X' : 'O')\r\n    }\r\n    return (\r\n      <React.Fragment>\r\n        <h1>Tic Tac Toe</h1>\r\n        <section className=\"game\">\r\n          <GameInfo\r\n            status={status}\r\n            winner={winner}\r\n            xIsNext={this.state.xIsNext}\r\n          />\r\n          <Board\r\n            squares={current.squares}\r\n            onClick={(i) => this.handleClick(i)}\r\n            jumpTo={(i) => this.jumpTo(i)}\r\n          />\r\n        </section>\r\n      </React.Fragment>\r\n    )\r\n  }\r\n}\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById('root'))\nroot.render(\n  <Router basename={process.env.REACT_APP_URI || \"/\"}>\n    <Routes>\n      <Route path=\"/\" element={<ChatPage />} />\n      <Route path=\"/tic-tac-toe\" element={<Game />} />\n    </Routes>\n  </Router>\n)\n",
      "truncated": false
    },
    {
      "uri": "file:///src/lib/tambo.ts",
      "path": "src/lib/tambo.ts",
      "name": "tambo.ts",
      "mimeType": "text/plain",
      "text": "/**\n * @file tambo.ts\n * @description Central configuration file for Tambo components and tools\n * \n * This file serves as the central place to register your Tambo components and tools.\n * It exports arrays that will be used by the TamboProvider.\n * \n * IMPORTANT: If you have components in different directories (e.g., both ui/ and tambo/),\n * make sure all import paths are consistent. Run 'npx tambo migrate' to consolidate.\n * \n * Read more about Tambo at https://docs.tambo.co\n */\n\nimport type { TamboComponent } from \"@tambo-ai/react\";\n\n\n/**\n * Components Array - A collection of Tambo components to register\n * \n * Components represent UI elements that can be generated or controlled by AI.\n * Register your custom components here to make them available to the AI.\n * \n * Example of adding a component:\n * \n * ```typescript\n * import { z } from \"zod/v4\";\n * import { CustomChart } from \"../components/ui/custom-chart\";\n * \n * // Define and add your component\n * export const components: TamboComponent[] = [\n *   {\n *     name: \"CustomChart\",\n *     description: \"Renders a custom chart with the provided data\",\n *     component: CustomChart,\n *     propsSchema: z.object({\n *       data: z.array(z.number()),\n *       title: z.string().optional(),\n *     })\n *   }\n * ];\n * ```\n */\nexport const components: TamboComponent[] = [];\n\n// Import your custom components that utilize the Tambo SDK\n// import { CustomChart } from \"../components/tambo/custom-chart\";\n",
      "truncated": false
    },
    {
      "uri": "file:///src/lib/thread-hooks.ts",
      "path": "src/lib/thread-hooks.ts",
      "name": "thread-hooks.ts",
      "mimeType": "text/plain",
      "text": "import type { TamboThreadMessage } from \"@tambo-ai/react\";\nimport * as React from \"react\";\nimport { useEffect, useState } from \"react\";\n\n/**\n * Converts message content to markdown format for rendering with streamdown.\n * Handles text and resource content parts, converting resources to markdown links\n * with a custom URL scheme that will be rendered as Mention components.\n *\n * @param content - The message content (string, element, array, etc.)\n * @returns A markdown string ready for streamdown rendering\n */\nexport function convertContentToMarkdown(\n  content: TamboThreadMessage[\"content\"] | React.ReactNode | undefined | null,\n): string {\n  if (!content) return \"\";\n  if (typeof content === \"string\") return content;\n  if (React.isValidElement(content)) {\n    // For React elements, we can't convert to markdown - this shouldn't happen\n    // in normal flow, but keep backward compatibility\n    return \"\";\n  }\n  if (Array.isArray(content)) {\n    const parts: string[] = [];\n    for (const item of content) {\n      if (item?.type === \"text\") {\n        parts.push(item.text ?? \"\");\n      } else if (item?.type === \"resource\") {\n        const resource = item.resource;\n        const uri = resource?.uri;\n        if (uri) {\n          // Use resource name for display, fallback to URI if no name\n          const displayName = resource?.name ?? uri;\n          // Use a custom protocol that looks more standard to avoid blocking\n          // Format: tambo-resource://<encoded-uri>\n          // We'll detect this in the link component and decode the URI\n          const encodedUri = encodeURIComponent(uri);\n          parts.push(`[${displayName}](tambo-resource://${encodedUri})`);\n        }\n      }\n    }\n    return parts.join(\" \");\n  }\n  return \"\";\n}\n\n/**\n * Merges multiple refs into a single callback ref.\n *\n * In React 19, callback refs may return cleanup functions; this hook fans out\n * both assignments and cleanups to all provided refs and tracks the last\n * cleanup so it runs when the instance changes.\n */\nexport function useMergeRefs<Instance>(\n  ...refs: (React.Ref<Instance> | undefined)[]\n): null | React.RefCallback<Instance> {\n  const cleanupRef = React.useRef<void | (() => void)>(undefined);\n\n  const refEffect = React.useCallback((instance: Instance | null) => {\n    const cleanups = refs.map((ref) => {\n      if (ref == null) {\n        return;\n      }\n\n      if (typeof ref === \"function\") {\n        const refCallback = ref;\n        const refCleanup: void | (() => void) = refCallback(instance);\n        return typeof refCleanup === \"function\"\n          ? refCleanup\n          : () => {\n              refCallback(null);\n            };\n      }\n\n      (ref as React.MutableRefObject<Instance | null>).current = instance;\n      return () => {\n        (ref as React.MutableRefObject<Instance | null>).current = null;\n      };\n    });\n\n    return () => {\n      cleanups.forEach((refCleanup) => refCleanup?.());\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n\n  return React.useMemo(() => {\n    if (refs.every((ref) => ref == null)) {\n      return null;\n    }\n\n    return (value) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        (cleanupRef as React.MutableRefObject<void | (() => void)>).current =\n          undefined;\n      }\n\n      if (value != null) {\n        (cleanupRef as React.MutableRefObject<void | (() => void)>).current =\n          refEffect(value);\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [refEffect, ...refs]);\n}\n/**\n * Custom hook to detect canvas space presence and position\n * @param elementRef - Reference to the component to compare position with\n * @returns Object containing hasCanvasSpace and canvasIsOnLeft\n */\nexport function useCanvasDetection(\n  elementRef: React.RefObject<HTMLElement | null>,\n) {\n  const [hasCanvasSpace, setHasCanvasSpace] = useState(false);\n  const [canvasIsOnLeft, setCanvasIsOnLeft] = useState(false);\n\n  useEffect(() => {\n    const checkCanvas = () => {\n      const canvas = document.querySelector('[data-canvas-space=\"true\"]');\n      setHasCanvasSpace(!!canvas);\n\n      if (canvas && elementRef.current) {\n        // Check if canvas appears before this component in the DOM\n        const canvasRect = canvas.getBoundingClientRect();\n        const elemRect = elementRef.current.getBoundingClientRect();\n        setCanvasIsOnLeft(canvasRect.left < elemRect.left);\n      }\n    };\n\n    // Check on mount and after a short delay to ensure DOM is fully rendered\n    checkCanvas();\n    const timeoutId = setTimeout(checkCanvas, 100);\n\n    // Re-check on window resize\n    window.addEventListener(\"resize\", checkCanvas);\n\n    return () => {\n      clearTimeout(timeoutId);\n      window.removeEventListener(\"resize\", checkCanvas);\n    };\n  }, [elementRef]);\n\n  return { hasCanvasSpace, canvasIsOnLeft };\n}\n\n/**\n * Utility to check if a className string contains the \"right\" class\n * @param className - The className string to check\n * @returns true if the className contains \"right\", false otherwise\n */\nexport function hasRightClass(className?: string): boolean {\n  return className ? /(?:^|\\s)right(?:\\s|$)/i.test(className) : false;\n}\n\n/**\n * Hook to calculate sidebar and history positions based on className and canvas position\n * @param className - Component's className string\n * @param canvasIsOnLeft - Whether the canvas is on the left\n * @returns Object with isLeftPanel and historyPosition values\n */\nexport function usePositioning(\n  className?: string,\n  canvasIsOnLeft = false,\n  hasCanvasSpace = false,\n) {\n  const isRightClass = hasRightClass(className);\n  const isLeftPanel = !isRightClass;\n\n  // Determine history position\n  // If panel has right class, history should be on right\n  // If canvas is on left, history should be on right\n  // Otherwise, history should be on left\n  let historyPosition: \"left\" | \"right\";\n  if (isRightClass) {\n    historyPosition = \"right\";\n  } else if (hasCanvasSpace && canvasIsOnLeft) {\n    historyPosition = \"right\";\n  } else {\n    historyPosition = \"left\";\n  }\n\n  return { isLeftPanel, historyPosition };\n}\n\n/**\n * Converts message content into a safely renderable format.\n * Handles text, resource references, and other content types.\n *\n * @deprecated This function is deprecated. Message rendering now uses a private\n * `convertContentToMarkdown()` function within the message component. This function\n * is kept for backward compatibility since it's exposed in the SDK.\n *\n * @param content - The message content (string, element, array, etc.)\n * @returns A renderable string or React element.\n */\nexport function getSafeContent(\n  content: TamboThreadMessage[\"content\"] | React.ReactNode | undefined | null,\n): string | React.ReactElement {\n  if (!content) return \"\";\n  if (typeof content === \"string\") return content;\n  if (React.isValidElement(content)) return content; // Pass elements through\n  if (Array.isArray(content)) {\n    // Map content parts to strings, including resource references\n    const parts: string[] = [];\n    for (const item of content) {\n      if (item?.type === \"text\") {\n        parts.push(item.text ?? \"\");\n      } else if (item?.type === \"resource\") {\n        // Format resource references as @uri (uri already contains serverKey prefix if applicable)\n        const uri = item.resource?.uri;\n        if (uri) {\n          parts.push(`@${uri}`);\n        }\n      }\n    }\n    return parts.join(\" \");\n  }\n  // Handle potential edge cases or unknown types\n  // console.warn(\"getSafeContent encountered unknown content type:\", content);\n  return \"Invalid content format\"; // Or handle differently\n}\n\n/**\n * Checks if a content item has meaningful data.\n * @param item - A content item from the message\n * @returns True if the item has content, false otherwise.\n */\nfunction hasContentInItem(item: unknown): boolean {\n  if (!item || typeof item !== \"object\") {\n    return false;\n  }\n\n  const typedItem = item as {\n    type?: string;\n    text?: string;\n    image_url?: { url?: string };\n  };\n\n  // Check for text content\n  if (typedItem.type === \"text\") {\n    return !!typedItem.text?.trim();\n  }\n\n  // Check for image content\n  if (typedItem.type === \"image_url\") {\n    return !!typedItem.image_url?.url;\n  }\n\n  return false;\n}\n\n/**\n * Checks if message content contains meaningful, non-empty text or images.\n * @param content - The message content (string, element, array, etc.)\n * @returns True if there is content, false otherwise.\n */\nexport function checkHasContent(\n  content: TamboThreadMessage[\"content\"] | React.ReactNode | undefined | null,\n): boolean {\n  if (!content) return false;\n  if (typeof content === \"string\") return content.trim().length > 0;\n  if (React.isValidElement(content)) return true; // Assume elements have content\n  if (Array.isArray(content)) {\n    return content.some(hasContentInItem);\n  }\n  return false; // Default for unknown types\n}\n\n/**\n * Extracts image URLs from message content array.\n * @param content - Array of content items\n * @returns Array of image URLs\n */\nexport function getMessageImages(\n  content: { type?: string; image_url?: { url?: string } }[] | undefined | null,\n): string[] {\n  if (!content) return [];\n\n  return content\n    .filter((item) => item?.type === \"image_url\" && item.image_url?.url)\n    .map((item) => item.image_url!.url!);\n}\n",
      "truncated": false
    },
    {
      "uri": "file:///src/lib/utils.ts",
      "path": "src/lib/utils.ts",
      "name": "utils.ts",
      "mimeType": "text/plain",
      "text": "import { clsx, type ClassValue } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs))\n}",
      "truncated": false
    },
    {
      "uri": "file:///src/reportWebVitals.js",
      "path": "src/reportWebVitals.js",
      "name": "reportWebVitals.js",
      "mimeType": "text/plain",
      "text": "const reportWebVitals = onPerfEntry => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n",
      "truncated": false
    },
    {
      "uri": "file:///src/setupTests.js",
      "path": "src/setupTests.js",
      "name": "setupTests.js",
      "mimeType": "text/plain",
      "text": "// jest-dom adds custom jest matchers for asserting on DOM nodes.\r\n// allows you to do things like:\r\n// expect(element).toHaveTextContent(/react/i)\r\n// learn more: https://github.com/testing-library/jest-dom\r\nimport '@testing-library/jest-dom';\r\n",
      "truncated": false
    }
  ]
}